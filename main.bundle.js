/*! For license information please see main.bundle.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./src/Lib/TTFLoader.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "TTFLoader": () => (/* binding */ TTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n/* harmony import */ var _opentype_module_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./opentype.module.min */ "./src/Lib/opentype.module.min.js");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n/**\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nvar TTFLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TTFLoader, _Loader);\n\n  var _super = _createSuper(TTFLoader);\n\n  function TTFLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, TTFLoader);\n\n    _this = _super.call(this, manager);\n    _this.reversed = false;\n    return _this;\n  }\n\n  _createClass(TTFLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\'arraybuffer\');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(scope.parse(buffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: "parse",\n    value: function parse(arraybuffer) {\n      function convert(font, reversed) {\n        var round = Math.round;\n        var glyphs = {};\n        var scale = 100000 / ((font.unitsPerEm || 2048) * 72);\n        var glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n        var unicodes = Object.keys(glyphIndexMap);\n\n        for (var i = 0; i < unicodes.length; i++) {\n          var unicode = unicodes[i];\n          var glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];\n\n          if (unicode !== undefined) {\n            (function () {\n              var token = {\n                ha: round(glyph.advanceWidth * scale),\n                x_min: round(glyph.xMin * scale),\n                x_max: round(glyph.xMax * scale),\n                o: \'\'\n              };\n\n              if (reversed) {\n                glyph.path.commands = reverseCommands(glyph.path.commands);\n              }\n\n              glyph.path.commands.forEach(function (command) {\n                if (command.type.toLowerCase() === \'c\') {\n                  command.type = \'b\';\n                }\n\n                token.o += command.type.toLowerCase() + \' \';\n\n                if (command.x !== undefined && command.y !== undefined) {\n                  token.o += round(command.x * scale) + \' \' + round(command.y * scale) + \' \';\n                }\n\n                if (command.x1 !== undefined && command.y1 !== undefined) {\n                  token.o += round(command.x1 * scale) + \' \' + round(command.y1 * scale) + \' \';\n                }\n\n                if (command.x2 !== undefined && command.y2 !== undefined) {\n                  token.o += round(command.x2 * scale) + \' \' + round(command.y2 * scale) + \' \';\n                }\n              });\n              glyphs[String.fromCodePoint(glyph.unicode)] = token;\n            })();\n          }\n        }\n\n        return {\n          glyphs: glyphs,\n          familyName: font.getEnglishName(\'fullName\'),\n          ascender: round(font.ascender * scale),\n          descender: round(font.descender * scale),\n          underlinePosition: font.tables.post.underlinePosition,\n          underlineThickness: font.tables.post.underlineThickness,\n          boundingBox: {\n            xMin: font.tables.head.xMin,\n            xMax: font.tables.head.xMax,\n            yMin: font.tables.head.yMin,\n            yMax: font.tables.head.yMax\n          },\n          resolution: 1000,\n          original_font_information: font.tables.name\n        };\n      }\n\n      function reverseCommands(commands) {\n        var paths = [];\n        var path;\n        commands.forEach(function (c) {\n          if (c.type.toLowerCase() === \'m\') {\n            path = [c];\n            paths.push(path);\n          } else if (c.type.toLowerCase() !== \'z\') {\n            path.push(c);\n          }\n        });\n        var reversed = [];\n        paths.forEach(function (p) {\n          var result = {\n            type: \'m\',\n            x: p[p.length - 1].x,\n            y: p[p.length - 1].y\n          };\n          reversed.push(result);\n\n          for (var i = p.length - 1; i > 0; i--) {\n            var command = p[i];\n            var _result = {\n              type: command.type\n            };\n\n            if (command.x2 !== undefined && command.y2 !== undefined) {\n              _result.x1 = command.x2;\n              _result.y1 = command.y2;\n              _result.x2 = command.x1;\n              _result.y2 = command.y1;\n            } else if (command.x1 !== undefined && command.y1 !== undefined) {\n              _result.x1 = command.x1;\n              _result.y1 = command.y1;\n            }\n\n            _result.x = p[i - 1].x;\n            _result.y = p[i - 1].y;\n            reversed.push(_result);\n          }\n        });\n        return reversed;\n      }\n\n      if (typeof _opentype_module_min__WEBPACK_IMPORTED_MODULE_0__.opentype === \'undefined\') {\n        console.warn(\'THREE.TTFLoader: The loader requires opentype.js. Make sure it\\\'s included before using the loader.\');\n        return null;\n      }\n\n      return convert(_opentype_module_min__WEBPACK_IMPORTED_MODULE_0__.opentype.parse(arraybuffer), this.reversed); // eslint-disable-line no-undef\n    }\n  }]);\n\n  return TTFLoader;\n}(three__WEBPACK_IMPORTED_MODULE_1__.Loader);\n\n\n\n//# sourceURL=webpack://font-research/./src/Lib/TTFLoader.js?')},"./src/Lib/opentype.module.min.js":(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "opentype": () => (/* binding */ opentype)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Modules in this bundle\n * @license\n *\n * opentype.js:\n *   license: MIT (http://opensource.org/licenses/MIT)\n *   author: Frederik De Bleser <frederik@debleser.be>\n *   version: 0.6.5\n *\n * tiny-inflate:\n *   license: MIT (http://opensource.org/licenses/MIT)\n *   author: Devon Govett <devongovett@gmail.com>\n *   maintainers: devongovett <devongovett@gmail.com>\n *   homepage: https://github.com/devongovett/tiny-inflate\n *   version: 1.0.2\n *\n * This header is generated by licensify (https://github.com/twada/licensify)\n */\n(function (f) {\n  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && "object" !== "undefined") {\n    module.exports = f();\n  } else if (typeof define === "function" && __webpack_require__.amdO) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== "undefined") {\n      g = window;\n    } else if (typeof __webpack_require__.g !== "undefined") {\n      g = __webpack_require__.g;\n    } else if (typeof self !== "undefined") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.opentype = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = undefined;\n          if (!u && a) return require(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error("Cannot find module \'" + o + "\'");\n          throw f.code = "MODULE_NOT_FOUND", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = undefined;\n\n    for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      function Tree() {\n        this.table = new Uint16Array(16), this.trans = new Uint16Array(288);\n      }\n\n      function Data(e, t) {\n        this.source = e, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t, this.destLen = 0, this.ltree = new Tree(), this.dtree = new Tree();\n      }\n\n      function tinf_build_bits_base(e, t, n, r) {\n        var s, i;\n\n        for (s = 0; n > s; ++s) {\n          e[s] = 0;\n        }\n\n        for (s = 0; 30 - n > s; ++s) {\n          e[s + n] = s / n | 0;\n        }\n\n        for (i = r, s = 0; 30 > s; ++s) {\n          t[s] = i, i += 1 << e[s];\n        }\n      }\n\n      function tinf_build_fixed_trees(e, t) {\n        var n;\n\n        for (n = 0; 7 > n; ++n) {\n          e.table[n] = 0;\n        }\n\n        for (e.table[7] = 24, e.table[8] = 152, e.table[9] = 112, n = 0; 24 > n; ++n) {\n          e.trans[n] = 256 + n;\n        }\n\n        for (n = 0; 144 > n; ++n) {\n          e.trans[24 + n] = n;\n        }\n\n        for (n = 0; 8 > n; ++n) {\n          e.trans[168 + n] = 280 + n;\n        }\n\n        for (n = 0; 112 > n; ++n) {\n          e.trans[176 + n] = 144 + n;\n        }\n\n        for (n = 0; 5 > n; ++n) {\n          t.table[n] = 0;\n        }\n\n        for (t.table[5] = 32, n = 0; 32 > n; ++n) {\n          t.trans[n] = n;\n        }\n      }\n\n      function tinf_build_tree(e, t, n, r) {\n        var s, i;\n\n        for (s = 0; 16 > s; ++s) {\n          e.table[s] = 0;\n        }\n\n        for (s = 0; r > s; ++s) {\n          e.table[t[n + s]]++;\n        }\n\n        for (e.table[0] = 0, i = 0, s = 0; 16 > s; ++s) {\n          offs[s] = i, i += e.table[s];\n        }\n\n        for (s = 0; r > s; ++s) {\n          t[n + s] && (e.trans[offs[t[n + s]]++] = s);\n        }\n      }\n\n      function tinf_getbit(e) {\n        e.bitcount-- || (e.tag = e.source[e.sourceIndex++], e.bitcount = 7);\n        var t = 1 & e.tag;\n        return e.tag >>>= 1, t;\n      }\n\n      function tinf_read_bits(e, t, n) {\n        if (!t) return n;\n\n        for (; e.bitcount < 24;) {\n          e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;\n        }\n\n        var r = e.tag & 65535 >>> 16 - t;\n        return e.tag >>>= t, e.bitcount -= t, r + n;\n      }\n\n      function tinf_decode_symbol(e, t) {\n        for (; e.bitcount < 24;) {\n          e.tag |= e.source[e.sourceIndex++] << e.bitcount, e.bitcount += 8;\n        }\n\n        var n = 0,\n            r = 0,\n            s = 0,\n            i = e.tag;\n\n        do {\n          r = 2 * r + (1 & i), i >>>= 1, ++s, n += t.table[s], r -= t.table[s];\n        } while (r >= 0);\n\n        return e.tag = i, e.bitcount -= s, t.trans[n + r];\n      }\n\n      function tinf_decode_trees(e, t, n) {\n        var r, s, i, a, o, _;\n\n        for (r = tinf_read_bits(e, 5, 257), s = tinf_read_bits(e, 5, 1), i = tinf_read_bits(e, 4, 4), a = 0; 19 > a; ++a) {\n          lengths[a] = 0;\n        }\n\n        for (a = 0; i > a; ++a) {\n          var f = tinf_read_bits(e, 3, 0);\n          lengths[clcidx[a]] = f;\n        }\n\n        for (tinf_build_tree(code_tree, lengths, 0, 19), o = 0; r + s > o;) {\n          var d = tinf_decode_symbol(e, code_tree);\n\n          switch (d) {\n            case 16:\n              var b = lengths[o - 1];\n\n              for (_ = tinf_read_bits(e, 2, 3); _; --_) {\n                lengths[o++] = b;\n              }\n\n              break;\n\n            case 17:\n              for (_ = tinf_read_bits(e, 3, 3); _; --_) {\n                lengths[o++] = 0;\n              }\n\n              break;\n\n            case 18:\n              for (_ = tinf_read_bits(e, 7, 11); _; --_) {\n                lengths[o++] = 0;\n              }\n\n              break;\n\n            default:\n              lengths[o++] = d;\n          }\n        }\n\n        tinf_build_tree(t, lengths, 0, r), tinf_build_tree(n, lengths, r, s);\n      }\n\n      function tinf_inflate_block_data(e, t, n) {\n        for (;;) {\n          var r = tinf_decode_symbol(e, t);\n          if (256 === r) return TINF_OK;\n          if (256 > r) e.dest[e.destLen++] = r;else {\n            var s, i, a, o;\n\n            for (r -= 257, s = tinf_read_bits(e, length_bits[r], length_base[r]), i = tinf_decode_symbol(e, n), a = e.destLen - tinf_read_bits(e, dist_bits[i], dist_base[i]), o = a; a + s > o; ++o) {\n              e.dest[e.destLen++] = e.dest[o];\n            }\n          }\n        }\n      }\n\n      function tinf_inflate_uncompressed_block(e) {\n        for (var t, n, r; e.bitcount > 8;) {\n          e.sourceIndex--, e.bitcount -= 8;\n        }\n\n        if (t = e.source[e.sourceIndex + 1], t = 256 * t + e.source[e.sourceIndex], n = e.source[e.sourceIndex + 3], n = 256 * n + e.source[e.sourceIndex + 2], t !== (65535 & ~n)) return TINF_DATA_ERROR;\n\n        for (e.sourceIndex += 4, r = t; r; --r) {\n          e.dest[e.destLen++] = e.source[e.sourceIndex++];\n        }\n\n        return e.bitcount = 0, TINF_OK;\n      }\n\n      function tinf_uncompress(e, t) {\n        var n,\n            r,\n            s,\n            i = new Data(e, t);\n\n        do {\n          switch (n = tinf_getbit(i), r = tinf_read_bits(i, 2, 0)) {\n            case 0:\n              s = tinf_inflate_uncompressed_block(i);\n              break;\n\n            case 1:\n              s = tinf_inflate_block_data(i, sltree, sdtree);\n              break;\n\n            case 2:\n              tinf_decode_trees(i, i.ltree, i.dtree), s = tinf_inflate_block_data(i, i.ltree, i.dtree);\n              break;\n\n            default:\n              s = TINF_DATA_ERROR;\n          }\n\n          if (s !== TINF_OK) throw new Error("Data error");\n        } while (!n);\n\n        return i.destLen < i.dest.length ? "function" == typeof i.dest.slice ? i.dest.slice(0, i.destLen) : i.dest.subarray(0, i.destLen) : i.dest;\n      }\n\n      var TINF_OK = 0,\n          TINF_DATA_ERROR = -3,\n          sltree = new Tree(),\n          sdtree = new Tree(),\n          length_bits = new Uint8Array(30),\n          length_base = new Uint16Array(30),\n          dist_bits = new Uint8Array(30),\n          dist_base = new Uint16Array(30),\n          clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n          code_tree = new Tree(),\n          lengths = new Uint8Array(320),\n          offs = new Uint16Array(16);\n      tinf_build_fixed_trees(sltree, sdtree), tinf_build_bits_base(length_bits, length_base, 4, 3), tinf_build_bits_base(dist_bits, dist_base, 2, 1), length_bits[28] = 0, length_base[28] = 258, module.exports = tinf_uncompress;\n    }, {}],\n    2: [function (require, module, exports) {\n      "use strict";\n\n      exports.fail = function (r) {\n        throw new Error(r);\n      }, exports.argument = function (r, t) {\n        r || exports.fail(t);\n      }, exports.assert = exports.argument;\n    }, {}],\n    3: [function (require, module, exports) {\n      "use strict";\n\n      function line(e, i, n, o, t) {\n        e.beginPath(), e.moveTo(i, n), e.lineTo(o, t), e.stroke();\n      }\n\n      exports.line = line;\n    }, {}],\n    4: [function (require, module, exports) {\n      "use strict";\n\n      function DefaultEncoding(e) {\n        this.font = e;\n      }\n\n      function CmapEncoding(e) {\n        this.cmap = e;\n      }\n\n      function CffEncoding(e, l) {\n        this.encoding = e, this.charset = l;\n      }\n\n      function GlyphNames(e) {\n        var l;\n\n        switch (e.version) {\n          case 1:\n            this.names = exports.standardNames.slice();\n            break;\n\n          case 2:\n            for (this.names = new Array(e.numberOfGlyphs), l = 0; l < e.numberOfGlyphs; l++) {\n              this.names[l] = e.glyphNameIndex[l] < exports.standardNames.length ? exports.standardNames[e.glyphNameIndex[l]] : e.names[e.glyphNameIndex[l] - exports.standardNames.length];\n            }\n\n            break;\n\n          case 2.5:\n            for (this.names = new Array(e.numberOfGlyphs), l = 0; l < e.numberOfGlyphs; l++) {\n              this.names[l] = exports.standardNames[l + e.glyphNameIndex[l]];\n            }\n\n            break;\n\n          case 3:\n            this.names = [];\n        }\n      }\n\n      function addGlyphNames(e) {\n        for (var l, r = e.tables.cmap.glyphIndexMap, a = Object.keys(r), s = 0; s < a.length; s += 1) {\n          var i = a[s],\n              o = r[i];\n          l = e.glyphs.get(o), l.addUnicode(parseInt(i));\n        }\n\n        for (s = 0; s < e.glyphs.length; s += 1) {\n          l = e.glyphs.get(s), e.cffEncoding ? l.name = e.cffEncoding.charset[s] : e.glyphNames.names && (l.name = e.glyphNames.glyphIndexToName(s));\n        }\n      }\n\n      var cffStandardStrings = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"],\n          cffStandardEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"],\n          cffExpertEncoding = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"],\n          standardNames = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];\n      DefaultEncoding.prototype.charToGlyphIndex = function (e) {\n        var l = e.charCodeAt(0),\n            r = this.font.glyphs;\n        if (!r) return null;\n\n        for (var a = 0; a < r.length; a += 1) {\n          for (var s = r.get(a), i = 0; i < s.unicodes.length; i += 1) {\n            if (s.unicodes[i] === l) return a;\n          }\n        }\n      }, CmapEncoding.prototype.charToGlyphIndex = function (e) {\n        return this.cmap.glyphIndexMap[e.charCodeAt(0)] || 0;\n      }, CffEncoding.prototype.charToGlyphIndex = function (e) {\n        var l = e.charCodeAt(0),\n            r = this.encoding[l];\n        return this.charset.indexOf(r);\n      }, GlyphNames.prototype.nameToGlyphIndex = function (e) {\n        return this.names.indexOf(e);\n      }, GlyphNames.prototype.glyphIndexToName = function (e) {\n        return this.names[e];\n      }, exports.cffStandardStrings = cffStandardStrings, exports.cffStandardEncoding = cffStandardEncoding, exports.cffExpertEncoding = cffExpertEncoding, exports.standardNames = standardNames, exports.DefaultEncoding = DefaultEncoding, exports.CmapEncoding = CmapEncoding, exports.CffEncoding = CffEncoding, exports.GlyphNames = GlyphNames, exports.addGlyphNames = addGlyphNames;\n    }, {}],\n    5: [function (require, module, exports) {\n      "use strict";\n\n      function Font(e) {\n        e = e || {}, e.empty || (util.checkArgument(e.familyName, "When creating a new Font object, familyName is required."), util.checkArgument(e.styleName, "When creating a new Font object, styleName is required."), util.checkArgument(e.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), util.checkArgument(e.ascender, "When creating a new Font object, ascender is required."), util.checkArgument(e.descender, "When creating a new Font object, descender is required."), util.checkArgument(e.descender < 0, "Descender should be negative (e.g. -512)."), this.names = {\n          fontFamily: {\n            en: e.familyName || " "\n          },\n          fontSubfamily: {\n            en: e.styleName || " "\n          },\n          fullName: {\n            en: e.fullName || e.familyName + " " + e.styleName\n          },\n          postScriptName: {\n            en: e.postScriptName || e.familyName + e.styleName\n          },\n          designer: {\n            en: e.designer || " "\n          },\n          designerURL: {\n            en: e.designerURL || " "\n          },\n          manufacturer: {\n            en: e.manufacturer || " "\n          },\n          manufacturerURL: {\n            en: e.manufacturerURL || " "\n          },\n          license: {\n            en: e.license || " "\n          },\n          licenseURL: {\n            en: e.licenseURL || " "\n          },\n          version: {\n            en: e.version || "Version 0.1"\n          },\n          description: {\n            en: e.description || " "\n          },\n          copyright: {\n            en: e.copyright || " "\n          },\n          trademark: {\n            en: e.trademark || " "\n          }\n        }, this.unitsPerEm = e.unitsPerEm || 1e3, this.ascender = e.ascender, this.descender = e.descender, this.createdTimestamp = e.createdTimestamp, this.tables = {\n          os2: {\n            usWeightClass: e.weightClass || this.usWeightClasses.MEDIUM,\n            usWidthClass: e.widthClass || this.usWidthClasses.MEDIUM,\n            fsSelection: e.fsSelection || this.fsSelectionValues.REGULAR\n          }\n        }), this.supported = !0, this.glyphs = new glyphset.GlyphSet(this, e.glyphs || []), this.encoding = new encoding.DefaultEncoding(this), this.substitution = new Substitution(this), this.tables = this.tables || {};\n      }\n\n      var path = require("./path"),\n          sfnt = require("./tables/sfnt"),\n          encoding = require("./encoding"),\n          glyphset = require("./glyphset"),\n          Substitution = require("./substitution"),\n          util = require("./util");\n\n      Font.prototype.hasChar = function (e) {\n        return null !== this.encoding.charToGlyphIndex(e);\n      }, Font.prototype.charToGlyphIndex = function (e) {\n        return this.encoding.charToGlyphIndex(e);\n      }, Font.prototype.charToGlyph = function (e) {\n        var t = this.charToGlyphIndex(e),\n            n = this.glyphs.get(t);\n        return n || (n = this.glyphs.get(0)), n;\n      }, Font.prototype.stringToGlyphs = function (e) {\n        for (var t = [], n = 0; n < e.length; n += 1) {\n          var i = e[n];\n          t.push(this.charToGlyph(i));\n        }\n\n        return t;\n      }, Font.prototype.nameToGlyphIndex = function (e) {\n        return this.glyphNames.nameToGlyphIndex(e);\n      }, Font.prototype.nameToGlyph = function (e) {\n        var t = this.nametoGlyphIndex(e),\n            n = this.glyphs.get(t);\n        return n || (n = this.glyphs.get(0)), n;\n      }, Font.prototype.glyphIndexToName = function (e) {\n        return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(e) : "";\n      }, Font.prototype.getKerningValue = function (e, t) {\n        e = e.index || e, t = t.index || t;\n        var n = this.getGposKerningValue;\n        return n ? n(e, t) : this.kerningPairs[e + "," + t] || 0;\n      }, Font.prototype.forEachGlyph = function (e, t, n, i, r, o) {\n        t = void 0 !== t ? t : 0, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 72, r = r || {};\n\n        for (var s = void 0 === r.kerning ? !0 : r.kerning, a = 1 / this.unitsPerEm * i, h = this.stringToGlyphs(e), u = 0; u < h.length; u += 1) {\n          var c = h[u];\n\n          if (o(c, t, n, i, r), c.advanceWidth && (t += c.advanceWidth * a), s && u < h.length - 1) {\n            var l = this.getKerningValue(c, h[u + 1]);\n            t += l * a;\n          }\n        }\n      }, Font.prototype.getPath = function (e, t, n, i, r) {\n        var o = new path.Path();\n        return this.forEachGlyph(e, t, n, i, r, function (e, t, n, i) {\n          var r = e.getPath(t, n, i);\n          o.extend(r);\n        }), o;\n      }, Font.prototype.getPaths = function (e, t, n, i, r) {\n        var o = [];\n        return this.forEachGlyph(e, t, n, i, r, function (e, t, n, i) {\n          var r = e.getPath(t, n, i);\n          o.push(r);\n        }), o;\n      }, Font.prototype.draw = function (e, t, n, i, r, o) {\n        this.getPath(t, n, i, r, o).draw(e);\n      }, Font.prototype.drawPoints = function (e, t, n, i, r, o) {\n        this.forEachGlyph(t, n, i, r, o, function (t, n, i, r) {\n          t.drawPoints(e, n, i, r);\n        });\n      }, Font.prototype.drawMetrics = function (e, t, n, i, r, o) {\n        this.forEachGlyph(t, n, i, r, o, function (t, n, i, r) {\n          t.drawMetrics(e, n, i, r);\n        });\n      }, Font.prototype.getEnglishName = function (e) {\n        var t = this.names[e];\n        return t ? t.en : void 0;\n      }, Font.prototype.validate = function () {\n        function e(e, t) {\n          e || n.push(t);\n        }\n\n        function t(t) {\n          var n = i.getEnglishName(t);\n          e(n && n.trim().length > 0, "No English " + t + " specified.");\n        }\n\n        var n = [],\n            i = this;\n        t("fontFamily"), t("weightName"), t("manufacturer"), t("copyright"), t("version"), e(this.unitsPerEm > 0, "No unitsPerEm specified.");\n      }, Font.prototype.toTables = function () {\n        return sfnt.fontToTable(this);\n      }, Font.prototype.toBuffer = function () {\n        return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer();\n      }, Font.prototype.toArrayBuffer = function () {\n        for (var e = this.toTables(), t = e.encode(), n = new ArrayBuffer(t.length), i = new Uint8Array(n), r = 0; r < t.length; r++) {\n          i[r] = t[r];\n        }\n\n        return n;\n      }, Font.prototype.download = function () {\n        var e = this.getEnglishName("fontFamily"),\n            t = this.getEnglishName("fontSubfamily"),\n            n = e.replace(/\\s/g, "") + "-" + t + ".otf",\n            i = this.toArrayBuffer();\n        if (util.isBrowser()) window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem, window.requestFileSystem(window.TEMPORARY, i.byteLength, function (e) {\n          e.root.getFile(n, {\n            create: !0\n          }, function (e) {\n            e.createWriter(function (t) {\n              var n = new DataView(i),\n                  r = new Blob([n], {\n                type: "font/opentype"\n              });\n              t.write(r), t.addEventListener("writeend", function () {\n                location.href = e.toURL();\n              }, !1);\n            });\n          });\n        }, function (e) {\n          throw new Error(e.name + ": " + e.message);\n        });else {\n          var r = require("fs"),\n              o = util.arrayBufferToNodeBuffer(i);\n\n          r.writeFileSync(n, o);\n        }\n      }, Font.prototype.fsSelectionValues = {\n        ITALIC: 1,\n        UNDERSCORE: 2,\n        NEGATIVE: 4,\n        OUTLINED: 8,\n        STRIKEOUT: 16,\n        BOLD: 32,\n        REGULAR: 64,\n        USER_TYPO_METRICS: 128,\n        WWS: 256,\n        OBLIQUE: 512\n      }, Font.prototype.usWidthClasses = {\n        ULTRA_CONDENSED: 1,\n        EXTRA_CONDENSED: 2,\n        CONDENSED: 3,\n        SEMI_CONDENSED: 4,\n        MEDIUM: 5,\n        SEMI_EXPANDED: 6,\n        EXPANDED: 7,\n        EXTRA_EXPANDED: 8,\n        ULTRA_EXPANDED: 9\n      }, Font.prototype.usWeightClasses = {\n        THIN: 100,\n        EXTRA_LIGHT: 200,\n        LIGHT: 300,\n        NORMAL: 400,\n        MEDIUM: 500,\n        SEMI_BOLD: 600,\n        BOLD: 700,\n        EXTRA_BOLD: 800,\n        BLACK: 900\n      }, exports.Font = Font;\n    }, {\n      "./encoding": 4,\n      "./glyphset": 7,\n      "./path": 11,\n      "./substitution": 12,\n      "./tables/sfnt": 31,\n      "./util": 33,\n      "fs": undefined\n    }],\n    6: [function (require, module, exports) {\n      "use strict";\n\n      function getPathDefinition(t, i) {\n        var e = i || {\n          commands: []\n        };\n        return {\n          configurable: !0,\n          get: function get() {\n            return "function" == typeof e && (e = e()), e;\n          },\n          set: function set(t) {\n            e = t;\n          }\n        };\n      }\n\n      function Glyph(t) {\n        this.bindConstructorValues(t);\n      }\n\n      var check = require("./check"),\n          draw = require("./draw"),\n          path = require("./path");\n\n      Glyph.prototype.bindConstructorValues = function (t) {\n        this.index = t.index || 0, this.name = t.name || null, this.unicode = t.unicode || void 0, this.unicodes = t.unicodes || void 0 !== t.unicode ? [t.unicode] : [], t.xMin && (this.xMin = t.xMin), t.yMin && (this.yMin = t.yMin), t.xMax && (this.xMax = t.xMax), t.yMax && (this.yMax = t.yMax), t.advanceWidth && (this.advanceWidth = t.advanceWidth), Object.defineProperty(this, "path", getPathDefinition(this, t.path));\n      }, Glyph.prototype.addUnicode = function (t) {\n        0 === this.unicodes.length && (this.unicode = t), this.unicodes.push(t);\n      }, Glyph.prototype.getPath = function (t, i, e, n) {\n        t = void 0 !== t ? t : 0, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : {\n          xScale: 1,\n          yScale: 1\n        }, e = void 0 !== e ? e : 72;\n\n        for (var a = 1 / this.path.unitsPerEm * e, h = n.xScale * a, o = n.yScale * a, r = new path.Path(), s = this.path.commands, p = 0; p < s.length; p += 1) {\n          var y = s[p];\n          "M" === y.type ? r.moveTo(t + y.x * h, i + -y.y * o) : "L" === y.type ? r.lineTo(t + y.x * h, i + -y.y * o) : "Q" === y.type ? r.quadraticCurveTo(t + y.x1 * h, i + -y.y1 * o, t + y.x * h, i + -y.y * o) : "C" === y.type ? r.curveTo(t + y.x1 * h, i + -y.y1 * o, t + y.x2 * h, i + -y.y2 * o, t + y.x * h, i + -y.y * o) : "Z" === y.type && r.closePath();\n        }\n\n        return r;\n      }, Glyph.prototype.getContours = function () {\n        if (void 0 === this.points) return [];\n\n        for (var t = [], i = [], e = 0; e < this.points.length; e += 1) {\n          var n = this.points[e];\n          i.push(n), n.lastPointOfContour && (t.push(i), i = []);\n        }\n\n        return check.argument(0 === i.length, "There are still points left in the current contour."), t;\n      }, Glyph.prototype.getMetrics = function () {\n        for (var t = this.path.commands, i = [], e = [], n = 0; n < t.length; n += 1) {\n          var a = t[n];\n          "Z" !== a.type && (i.push(a.x), e.push(a.y)), ("Q" === a.type || "C" === a.type) && (i.push(a.x1), e.push(a.y1)), "C" === a.type && (i.push(a.x2), e.push(a.y2));\n        }\n\n        var h = {\n          xMin: Math.min.apply(null, i),\n          yMin: Math.min.apply(null, e),\n          xMax: Math.max.apply(null, i),\n          yMax: Math.max.apply(null, e),\n          leftSideBearing: this.leftSideBearing\n        };\n        return isFinite(h.xMin) || (h.xMin = 0), isFinite(h.xMax) || (h.xMax = this.advanceWidth), isFinite(h.yMin) || (h.yMin = 0), isFinite(h.yMax) || (h.yMax = 0), h.rightSideBearing = this.advanceWidth - h.leftSideBearing - (h.xMax - h.xMin), h;\n      }, Glyph.prototype.draw = function (t, i, e, n, a) {\n        this.getPath(i, e, n, a).draw(t);\n      }, Glyph.prototype.drawPoints = function (t, i, e, n) {\n        function a(i, e, n, a) {\n          var h = 2 * Math.PI;\n          t.beginPath();\n\n          for (var o = 0; o < i.length; o += 1) {\n            t.moveTo(e + i[o].x * a, n + i[o].y * a), t.arc(e + i[o].x * a, n + i[o].y * a, 2, 0, h, !1);\n          }\n\n          t.closePath(), t.fill();\n        }\n\n        i = void 0 !== i ? i : 0, e = void 0 !== e ? e : 0, n = void 0 !== n ? n : 24;\n\n        for (var h = 1 / this.path.unitsPerEm * n, o = [], r = [], s = this.path, p = 0; p < s.commands.length; p += 1) {\n          var y = s.commands[p];\n          void 0 !== y.x && o.push({\n            x: y.x,\n            y: -y.y\n          }), void 0 !== y.x1 && r.push({\n            x: y.x1,\n            y: -y.y1\n          }), void 0 !== y.x2 && r.push({\n            x: y.x2,\n            y: -y.y2\n          });\n        }\n\n        t.fillStyle = "blue", a(o, i, e, h), t.fillStyle = "red", a(r, i, e, h);\n      }, Glyph.prototype.drawMetrics = function (t, i, e, n) {\n        var a;\n        i = void 0 !== i ? i : 0, e = void 0 !== e ? e : 0, n = void 0 !== n ? n : 24, a = 1 / this.path.unitsPerEm * n, t.lineWidth = 1, t.strokeStyle = "black", draw.line(t, i, -1e4, i, 1e4), draw.line(t, -1e4, e, 1e4, e);\n        var h = this.xMin || 0,\n            o = this.yMin || 0,\n            r = this.xMax || 0,\n            s = this.yMax || 0,\n            p = this.advanceWidth || 0;\n        t.strokeStyle = "blue", draw.line(t, i + h * a, -1e4, i + h * a, 1e4), draw.line(t, i + r * a, -1e4, i + r * a, 1e4), draw.line(t, -1e4, e + -o * a, 1e4, e + -o * a), draw.line(t, -1e4, e + -s * a, 1e4, e + -s * a), t.strokeStyle = "green", draw.line(t, i + p * a, -1e4, i + p * a, 1e4);\n      }, exports.Glyph = Glyph;\n    }, {\n      "./check": 2,\n      "./draw": 3,\n      "./path": 11\n    }],\n    7: [function (require, module, exports) {\n      "use strict";\n\n      function defineDependentProperty(e, t, n) {\n        Object.defineProperty(e, t, {\n          get: function get() {\n            return e.path, e[n];\n          },\n          set: function set(t) {\n            e[n] = t;\n          },\n          enumerable: !0,\n          configurable: !0\n        });\n      }\n\n      function GlyphSet(e, t) {\n        if (this.font = e, this.glyphs = {}, Array.isArray(t)) for (var n = 0; n < t.length; n++) {\n          this.glyphs[n] = t[n];\n        }\n        this.length = t && t.length || 0;\n      }\n\n      function glyphLoader(e, t) {\n        return new _glyph.Glyph({\n          index: t,\n          font: e\n        });\n      }\n\n      function ttfGlyphLoader(e, t, n, r, p, h) {\n        return function () {\n          var i = new _glyph.Glyph({\n            index: t,\n            font: e\n          });\n          return i.path = function () {\n            n(i, r, p);\n            var t = h(e.glyphs, i);\n            return t.unitsPerEm = e.unitsPerEm, t;\n          }, defineDependentProperty(i, "xMin", "_xMin"), defineDependentProperty(i, "xMax", "_xMax"), defineDependentProperty(i, "yMin", "_yMin"), defineDependentProperty(i, "yMax", "_yMax"), i;\n        };\n      }\n\n      function cffGlyphLoader(e, t, n, r) {\n        return function () {\n          var p = new _glyph.Glyph({\n            index: t,\n            font: e\n          });\n          return p.path = function () {\n            var t = n(e, p, r);\n            return t.unitsPerEm = e.unitsPerEm, t;\n          }, p;\n        };\n      }\n\n      var _glyph = require("./glyph");\n\n      GlyphSet.prototype.get = function (e) {\n        return "function" == typeof this.glyphs[e] && (this.glyphs[e] = this.glyphs[e]()), this.glyphs[e];\n      }, GlyphSet.prototype.push = function (e, t) {\n        this.glyphs[e] = t, this.length++;\n      }, exports.GlyphSet = GlyphSet, exports.glyphLoader = glyphLoader, exports.ttfGlyphLoader = ttfGlyphLoader, exports.cffGlyphLoader = cffGlyphLoader;\n    }, {\n      "./glyph": 6\n    }],\n    8: [function (require, module, exports) {\n      "use strict";\n\n      function searchTag(e, r) {\n        for (var t = 0, a = e.length - 1; a >= t;) {\n          var s = t + a >>> 1,\n              n = e[s].tag;\n          if (n === r) return s;\n          r > n ? t = s + 1 : a = s - 1;\n        }\n\n        return -t - 1;\n      }\n\n      function binSearch(e, r) {\n        for (var t = 0, a = e.length - 1; a >= t;) {\n          var s = t + a >>> 1,\n              n = e[s];\n          if (n === r) return s;\n          r > n ? t = s + 1 : a = s - 1;\n        }\n\n        return -t - 1;\n      }\n\n      var check = require("./check"),\n          Layout = {\n        searchTag: searchTag,\n        binSearch: binSearch,\n        getScriptNames: function getScriptNames() {\n          var e = this.getGsubTable();\n          return e ? e.scripts.map(function (e) {\n            return e.tag;\n          }) : [];\n        },\n        getScriptTable: function getScriptTable(e, r) {\n          var t = this.getGsubTable(r);\n\n          if (t) {\n            var a = t.scripts,\n                s = searchTag(t.scripts, e);\n            if (s >= 0) return a[s].script;\n            var n = {\n              tag: e,\n              script: {\n                defaultLangSys: {\n                  reserved: 0,\n                  reqFeatureIndex: 65535,\n                  featureIndexes: []\n                },\n                langSysRecords: []\n              }\n            };\n            return a.splice(-1 - s, 0, n.script), n;\n          }\n        },\n        getLangSysTable: function getLangSysTable(e, r, t) {\n          var a = this.getScriptTable(e, t);\n\n          if (a) {\n            if ("DFLT" === r) return a.defaultLangSys;\n            var s = searchTag(a.langSysRecords, r);\n            if (s >= 0) return a.langSysRecords[s].langSys;\n\n            if (t) {\n              var n = {\n                tag: r,\n                langSys: {\n                  reserved: 0,\n                  reqFeatureIndex: 65535,\n                  featureIndexes: []\n                }\n              };\n              return a.langSysRecords.splice(-1 - s, 0, n), n.langSys;\n            }\n          }\n        },\n        getFeatureTable: function getFeatureTable(e, r, t, a) {\n          var s = this.getLangSysTable(e, r, a);\n\n          if (s) {\n            for (var n, u = s.featureIndexes, i = this.font.tables.gsub.features, g = 0; g < u.length; g++) {\n              if (n = i[u[g]], n.tag === t) return n.feature;\n            }\n\n            if (a) {\n              var o = i.length;\n              return check.assert(0 === o || t >= i[o - 1].tag, "Features must be added in alphabetical order."), n = {\n                tag: t,\n                feature: {\n                  params: 0,\n                  lookupListIndexes: []\n                }\n              }, i.push(n), u.push(o), n.feature;\n            }\n          }\n        },\n        getLookupTable: function getLookupTable(e, r, t, a, s) {\n          var n = this.getFeatureTable(e, r, t, s);\n\n          if (n) {\n            for (var u, i = n.lookupListIndexes, g = this.font.tables.gsub.lookups, o = 0; o < i.length; o++) {\n              if (u = g[i[o]], u.lookupType === a) return u;\n            }\n\n            if (s) {\n              u = {\n                lookupType: a,\n                lookupFlag: 0,\n                subtables: [],\n                markFilteringSet: void 0\n              };\n              var f = g.length;\n              return g.push(u), i.push(f), u;\n            }\n          }\n        },\n        expandCoverage: function expandCoverage(e) {\n          if (1 === e.format) return e.glyphs;\n\n          for (var r = [], t = e.ranges, a = 0; t > a; a++) {\n            for (var s = t[a], n = s.start, u = s.end, i = n; u >= i; i++) {\n              r.push(i);\n            }\n          }\n\n          return r;\n        }\n      };\n\n      module.exports = Layout;\n    }, {\n      "./check": 2\n    }],\n    9: [function (require, module, exports) {\n      "use strict";\n\n      function loadFromFile(e, a) {\n        var r = require("fs");\n\n        r.readFile(e, function (e, r) {\n          return e ? a(e.message) : void a(null, util.nodeBufferToArrayBuffer(r));\n        });\n      }\n\n      function loadFromUrl(e, a) {\n        var r = new XMLHttpRequest();\n        r.open("get", e, !0), r.responseType = "arraybuffer", r.onload = function () {\n          return 200 !== r.status ? a("Font could not be loaded: " + r.statusText) : a(null, r.response);\n        }, r.send();\n      }\n\n      function parseOpenTypeTableEntries(e, a) {\n        for (var r = [], s = 12, t = 0; a > t; t += 1) {\n          var n = parse.getTag(e, s),\n              o = parse.getULong(e, s + 4),\n              p = parse.getULong(e, s + 8),\n              l = parse.getULong(e, s + 12);\n          r.push({\n            tag: n,\n            checksum: o,\n            offset: p,\n            length: l,\n            compression: !1\n          }), s += 16;\n        }\n\n        return r;\n      }\n\n      function parseWOFFTableEntries(e, a) {\n        for (var r = [], s = 44, t = 0; a > t; t += 1) {\n          var n,\n              o = parse.getTag(e, s),\n              p = parse.getULong(e, s + 4),\n              l = parse.getULong(e, s + 8),\n              f = parse.getULong(e, s + 12);\n          n = f > l ? "WOFF" : !1, r.push({\n            tag: o,\n            offset: p,\n            compression: n,\n            compressedLength: l,\n            originalLength: f\n          }), s += 20;\n        }\n\n        return r;\n      }\n\n      function uncompressTable(e, a) {\n        if ("WOFF" === a.compression) {\n          var r = new Uint8Array(e.buffer, a.offset + 2, a.compressedLength - 2),\n              s = new Uint8Array(a.originalLength);\n          if (inflate(r, s), s.byteLength !== a.originalLength) throw new Error("Decompression error: " + a.tag + " decompressed length doesn\'t match recorded length");\n          var t = new DataView(s.buffer, 0);\n          return {\n            data: t,\n            offset: 0\n          };\n        }\n\n        return {\n          data: e,\n          offset: a.offset\n        };\n      }\n\n      function parseBuffer(e) {\n        var a,\n            r,\n            s,\n            t = new _font.Font({\n          empty: !0\n        }),\n            n = new DataView(e, 0),\n            o = [],\n            p = parse.getTag(n, 0);\n        if (p === String.fromCharCode(0, 1, 0, 0)) t.outlinesFormat = "truetype", s = parse.getUShort(n, 4), o = parseOpenTypeTableEntries(n, s);else if ("OTTO" === p) t.outlinesFormat = "cff", s = parse.getUShort(n, 4), o = parseOpenTypeTableEntries(n, s);else {\n          if ("wOFF" !== p) throw new Error("Unsupported OpenType signature " + p);\n          var l = parse.getTag(n, 4);\n          if (l === String.fromCharCode(0, 1, 0, 0)) t.outlinesFormat = "truetype";else {\n            if ("OTTO" !== l) throw new Error("Unsupported OpenType flavor " + p);\n            t.outlinesFormat = "cff";\n          }\n          s = parse.getUShort(n, 12), o = parseWOFFTableEntries(n, s);\n        }\n\n        for (var f, u, i, c, b, m, d, g, h, T, y = 0; s > y; y += 1) {\n          var v,\n              F = o[y];\n\n          switch (F.tag) {\n            case "cmap":\n              v = uncompressTable(n, F), t.tables.cmap = cmap.parse(v.data, v.offset), t.encoding = new encoding.CmapEncoding(t.tables.cmap);\n              break;\n\n            case "fvar":\n              u = F;\n              break;\n\n            case "head":\n              v = uncompressTable(n, F), t.tables.head = head.parse(v.data, v.offset), t.unitsPerEm = t.tables.head.unitsPerEm, a = t.tables.head.indexToLocFormat;\n              break;\n\n            case "hhea":\n              v = uncompressTable(n, F), t.tables.hhea = hhea.parse(v.data, v.offset), t.ascender = t.tables.hhea.ascender, t.descender = t.tables.hhea.descender, t.numberOfHMetrics = t.tables.hhea.numberOfHMetrics;\n              break;\n\n            case "hmtx":\n              m = F;\n              break;\n\n            case "ltag":\n              v = uncompressTable(n, F), r = ltag.parse(v.data, v.offset);\n              break;\n\n            case "maxp":\n              v = uncompressTable(n, F), t.tables.maxp = maxp.parse(v.data, v.offset), t.numGlyphs = t.tables.maxp.numGlyphs;\n              break;\n\n            case "name":\n              h = F;\n              break;\n\n            case "OS/2":\n              v = uncompressTable(n, F), t.tables.os2 = os2.parse(v.data, v.offset);\n              break;\n\n            case "post":\n              v = uncompressTable(n, F), t.tables.post = post.parse(v.data, v.offset), t.glyphNames = new encoding.GlyphNames(t.tables.post);\n              break;\n\n            case "glyf":\n              i = F;\n              break;\n\n            case "loca":\n              g = F;\n              break;\n\n            case "CFF ":\n              f = F;\n              break;\n\n            case "kern":\n              d = F;\n              break;\n\n            case "GPOS":\n              c = F;\n              break;\n\n            case "GSUB":\n              b = F;\n              break;\n\n            case "meta":\n              T = F;\n          }\n        }\n\n        var q = uncompressTable(n, h);\n\n        if (t.tables.name = _name.parse(q.data, q.offset, r), t.names = t.tables.name, i && g) {\n          var k = 0 === a,\n              w = uncompressTable(n, g),\n              x = loca.parse(w.data, w.offset, t.numGlyphs, k),\n              O = uncompressTable(n, i);\n          t.glyphs = glyf.parse(O.data, O.offset, x, t);\n        } else {\n          if (!f) throw new Error("Font doesn\'t contain TrueType or CFF outlines.");\n          var U = uncompressTable(n, f);\n          cff.parse(U.data, U.offset, t);\n        }\n\n        var L = uncompressTable(n, m);\n\n        if (hmtx.parse(L.data, L.offset, t.numberOfHMetrics, t.numGlyphs, t.glyphs), encoding.addGlyphNames(t), d) {\n          var E = uncompressTable(n, d);\n          t.kerningPairs = kern.parse(E.data, E.offset);\n        } else t.kerningPairs = {};\n\n        if (c) {\n          var S = uncompressTable(n, c);\n          gpos.parse(S.data, S.offset, t);\n        }\n\n        if (b) {\n          var G = uncompressTable(n, b);\n          t.tables.gsub = gsub.parse(G.data, G.offset);\n        }\n\n        if (u) {\n          var B = uncompressTable(n, u);\n          t.tables.fvar = fvar.parse(B.data, B.offset, t.names);\n        }\n\n        if (T) {\n          var C = uncompressTable(n, T);\n          t.tables.meta = meta.parse(C.data, C.offset), t.metas = t.tables.meta;\n        }\n\n        return t;\n      }\n\n      function load(e, a) {\n        var r = "undefined" == typeof window,\n            s = r ? loadFromFile : loadFromUrl;\n        s(e, function (e, r) {\n          if (e) return a(e);\n          var s;\n\n          try {\n            s = parseBuffer(r);\n          } catch (t) {\n            return a(t, null);\n          }\n\n          return a(null, s);\n        });\n      }\n\n      function loadSync(e) {\n        var a = require("fs"),\n            r = a.readFileSync(e);\n\n        return parseBuffer(util.nodeBufferToArrayBuffer(r));\n      }\n\n      var inflate = require("tiny-inflate"),\n          encoding = require("./encoding"),\n          _font = require("./font"),\n          glyph = require("./glyph"),\n          parse = require("./parse"),\n          path = require("./path"),\n          util = require("./util"),\n          cmap = require("./tables/cmap"),\n          cff = require("./tables/cff"),\n          fvar = require("./tables/fvar"),\n          glyf = require("./tables/glyf"),\n          gpos = require("./tables/gpos"),\n          gsub = require("./tables/gsub"),\n          head = require("./tables/head"),\n          hhea = require("./tables/hhea"),\n          hmtx = require("./tables/hmtx"),\n          kern = require("./tables/kern"),\n          ltag = require("./tables/ltag"),\n          loca = require("./tables/loca"),\n          maxp = require("./tables/maxp"),\n          _name = require("./tables/name"),\n          os2 = require("./tables/os2"),\n          post = require("./tables/post"),\n          meta = require("./tables/meta");\n\n      exports._parse = parse, exports.Font = _font.Font, exports.Glyph = glyph.Glyph, exports.Path = path.Path, exports.parse = parseBuffer, exports.load = load, exports.loadSync = loadSync;\n    }, {\n      "./encoding": 4,\n      "./font": 5,\n      "./glyph": 6,\n      "./parse": 10,\n      "./path": 11,\n      "./tables/cff": 14,\n      "./tables/cmap": 15,\n      "./tables/fvar": 16,\n      "./tables/glyf": 17,\n      "./tables/gpos": 18,\n      "./tables/gsub": 19,\n      "./tables/head": 20,\n      "./tables/hhea": 21,\n      "./tables/hmtx": 22,\n      "./tables/kern": 23,\n      "./tables/loca": 24,\n      "./tables/ltag": 25,\n      "./tables/maxp": 26,\n      "./tables/meta": 27,\n      "./tables/name": 28,\n      "./tables/os2": 29,\n      "./tables/post": 30,\n      "./util": 33,\n      "fs": undefined,\n      "tiny-inflate": 1\n    }],\n    10: [function (require, module, exports) {\n      "use strict";\n\n      function getUShort(t, r) {\n        return t.getUint16(r, !1);\n      }\n\n      function Parser(t, r) {\n        this.data = t, this.offset = r, this.relativeOffset = 0;\n      }\n\n      var check = require("./check");\n\n      exports.getByte = function (t, r) {\n        return t.getUint8(r);\n      }, exports.getCard8 = exports.getByte, exports.getUShort = exports.getCard16 = getUShort, exports.getShort = function (t, r) {\n        return t.getInt16(r, !1);\n      }, exports.getULong = function (t, r) {\n        return t.getUint32(r, !1);\n      }, exports.getFixed = function (t, r) {\n        var e = t.getInt16(r, !1),\n            s = t.getUint16(r + 2, !1);\n        return e + s / 65535;\n      }, exports.getTag = function (t, r) {\n        for (var e = "", s = r; r + 4 > s; s += 1) {\n          e += String.fromCharCode(t.getInt8(s));\n        }\n\n        return e;\n      }, exports.getOffset = function (t, r, e) {\n        for (var s = 0, a = 0; e > a; a += 1) {\n          s <<= 8, s += t.getUint8(r + a);\n        }\n\n        return s;\n      }, exports.getBytes = function (t, r, e) {\n        for (var s = [], a = r; e > a; a += 1) {\n          s.push(t.getUint8(a));\n        }\n\n        return s;\n      }, exports.bytesToString = function (t) {\n        for (var r = "", e = 0; e < t.length; e += 1) {\n          r += String.fromCharCode(t[e]);\n        }\n\n        return r;\n      };\n      var typeOffsets = {\n        "byte": 1,\n        uShort: 2,\n        "short": 2,\n        uLong: 4,\n        fixed: 4,\n        longDateTime: 8,\n        tag: 4\n      };\n      Parser.prototype.parseByte = function () {\n        var t = this.data.getUint8(this.offset + this.relativeOffset);\n        return this.relativeOffset += 1, t;\n      }, Parser.prototype.parseChar = function () {\n        var t = this.data.getInt8(this.offset + this.relativeOffset);\n        return this.relativeOffset += 1, t;\n      }, Parser.prototype.parseCard8 = Parser.prototype.parseByte, Parser.prototype.parseUShort = function () {\n        var t = this.data.getUint16(this.offset + this.relativeOffset);\n        return this.relativeOffset += 2, t;\n      }, Parser.prototype.parseCard16 = Parser.prototype.parseUShort, Parser.prototype.parseSID = Parser.prototype.parseUShort, Parser.prototype.parseOffset16 = Parser.prototype.parseUShort, Parser.prototype.parseShort = function () {\n        var t = this.data.getInt16(this.offset + this.relativeOffset);\n        return this.relativeOffset += 2, t;\n      }, Parser.prototype.parseF2Dot14 = function () {\n        var t = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n        return this.relativeOffset += 2, t;\n      }, Parser.prototype.parseULong = function () {\n        var t = exports.getULong(this.data, this.offset + this.relativeOffset);\n        return this.relativeOffset += 4, t;\n      }, Parser.prototype.parseFixed = function () {\n        var t = exports.getFixed(this.data, this.offset + this.relativeOffset);\n        return this.relativeOffset += 4, t;\n      }, Parser.prototype.parseString = function (t) {\n        var r = this.data,\n            e = this.offset + this.relativeOffset,\n            s = "";\n        this.relativeOffset += t;\n\n        for (var a = 0; t > a; a++) {\n          s += String.fromCharCode(r.getUint8(e + a));\n        }\n\n        return s;\n      }, Parser.prototype.parseTag = function () {\n        return this.parseString(4);\n      }, Parser.prototype.parseLongDateTime = function () {\n        var t = exports.getULong(this.data, this.offset + this.relativeOffset + 4);\n        return t -= 2082844800, this.relativeOffset += 8, t;\n      }, Parser.prototype.parseVersion = function () {\n        var t = getUShort(this.data, this.offset + this.relativeOffset),\n            r = getUShort(this.data, this.offset + this.relativeOffset + 2);\n        return this.relativeOffset += 4, t + r / 4096 / 10;\n      }, Parser.prototype.skip = function (t, r) {\n        void 0 === r && (r = 1), this.relativeOffset += typeOffsets[t] * r;\n      }, Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function (t) {\n        void 0 === t && (t = this.parseUShort());\n\n        for (var r = new Array(t), e = this.data, s = this.offset + this.relativeOffset, a = 0; t > a; a++) {\n          r[a] = e.getUint16(s), s += 2;\n        }\n\n        return this.relativeOffset += 2 * t, r;\n      }, Parser.prototype.parseList = function (t, r) {\n        r || (r = t, t = this.parseUShort());\n\n        for (var e = new Array(t), s = 0; t > s; s++) {\n          e[s] = r.call(this);\n        }\n\n        return e;\n      }, Parser.prototype.parseRecordList = function (t, r) {\n        r || (r = t, t = this.parseUShort());\n\n        for (var e = new Array(t), s = Object.keys(r), a = 0; t > a; a++) {\n          for (var o = {}, i = 0; i < s.length; i++) {\n            var n = s[i],\n                f = r[n];\n            o[n] = f.call(this);\n          }\n\n          e[a] = o;\n        }\n\n        return e;\n      }, Parser.prototype.parseStruct = function (t) {\n        if ("function" == typeof t) return t.call(this);\n\n        for (var r = Object.keys(t), e = {}, s = 0; s < r.length; s++) {\n          var a = r[s],\n              o = t[a];\n          e[a] = o.call(this);\n        }\n\n        return e;\n      }, Parser.prototype.parsePointer = function (t) {\n        var r = this.parseOffset16();\n        return r > 0 ? new Parser(this.data, this.offset + r).parseStruct(t) : void 0;\n      }, Parser.prototype.parseListOfLists = function (t) {\n        for (var r = this.parseOffset16List(), e = r.length, s = this.relativeOffset, a = new Array(e), o = 0; e > o; o++) {\n          var i = r[o];\n          if (0 !== i) {\n            if (this.relativeOffset = i, t) {\n              for (var n = this.parseOffset16List(), f = new Array(n.length), p = 0; p < n.length; p++) {\n                this.relativeOffset = i + n[p], f[p] = t.call(this);\n              }\n\n              a[o] = f;\n            } else a[o] = this.parseUShortList();\n          } else a[o] = void 0;\n        }\n\n        return this.relativeOffset = s, a;\n      }, Parser.prototype.parseCoverage = function () {\n        var t = this.offset + this.relativeOffset,\n            r = this.parseUShort(),\n            e = this.parseUShort();\n        if (1 === r) return {\n          format: 1,\n          glyphs: this.parseUShortList(e)\n        };\n\n        if (2 === r) {\n          for (var s = new Array(e), a = 0; e > a; a++) {\n            s[a] = {\n              start: this.parseUShort(),\n              end: this.parseUShort(),\n              index: this.parseUShort()\n            };\n          }\n\n          return {\n            format: 2,\n            ranges: s\n          };\n        }\n\n        check.assert(!1, "0x" + t.toString(16) + ": Coverage format must be 1 or 2.");\n      }, Parser.prototype.parseClassDef = function () {\n        var t = this.offset + this.relativeOffset,\n            r = this.parseUShort();\n        return 1 === r ? {\n          format: 1,\n          startGlyph: this.parseUShort(),\n          classes: this.parseUShortList()\n        } : 2 === r ? {\n          format: 2,\n          ranges: this.parseRecordList({\n            start: Parser.uShort,\n            end: Parser.uShort,\n            classId: Parser.uShort\n          })\n        } : void check.assert(!1, "0x" + t.toString(16) + ": ClassDef format must be 1 or 2.");\n      }, Parser.list = function (t, r) {\n        return function () {\n          return this.parseList(t, r);\n        };\n      }, Parser.recordList = function (t, r) {\n        return function () {\n          return this.parseRecordList(t, r);\n        };\n      }, Parser.pointer = function (t) {\n        return function () {\n          return this.parsePointer(t);\n        };\n      }, Parser.tag = Parser.prototype.parseTag, Parser["byte"] = Parser.prototype.parseByte, Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort, Parser.uShortList = Parser.prototype.parseUShortList, Parser.struct = Parser.prototype.parseStruct, Parser.coverage = Parser.prototype.parseCoverage, Parser.classDef = Parser.prototype.parseClassDef;\n      var langSysTable = {\n        reserved: Parser.uShort,\n        reqFeatureIndex: Parser.uShort,\n        featureIndexes: Parser.uShortList\n      };\n      Parser.prototype.parseScriptList = function () {\n        return this.parsePointer(Parser.recordList({\n          tag: Parser.tag,\n          script: Parser.pointer({\n            defaultLangSys: Parser.pointer(langSysTable),\n            langSysRecords: Parser.recordList({\n              tag: Parser.tag,\n              langSys: Parser.pointer(langSysTable)\n            })\n          })\n        }));\n      }, Parser.prototype.parseFeatureList = function () {\n        return this.parsePointer(Parser.recordList({\n          tag: Parser.tag,\n          feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n          })\n        }));\n      }, Parser.prototype.parseLookupList = function (t) {\n        return this.parsePointer(Parser.list(Parser.pointer(function () {\n          var r = this.parseUShort();\n          check.argument(r >= 1 && 8 >= r, "GSUB lookup type " + r + " unknown.");\n          var e = this.parseUShort(),\n              s = 16 & e;\n          return {\n            lookupType: r,\n            lookupFlag: e,\n            subtables: this.parseList(Parser.pointer(t[r])),\n            markFilteringSet: s ? this.parseUShort() : void 0\n          };\n        })));\n      }, exports.Parser = Parser;\n    }, {\n      "./check": 2\n    }],\n    11: [function (require, module, exports) {\n      "use strict";\n\n      function Path() {\n        this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1;\n      }\n\n      Path.prototype.moveTo = function (t, o) {\n        this.commands.push({\n          type: "M",\n          x: t,\n          y: o\n        });\n      }, Path.prototype.lineTo = function (t, o) {\n        this.commands.push({\n          type: "L",\n          x: t,\n          y: o\n        });\n      }, Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (t, o, e, i, s, h) {\n        this.commands.push({\n          type: "C",\n          x1: t,\n          y1: o,\n          x2: e,\n          y2: i,\n          x: s,\n          y: h\n        });\n      }, Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (t, o, e, i) {\n        this.commands.push({\n          type: "Q",\n          x1: t,\n          y1: o,\n          x: e,\n          y: i\n        });\n      }, Path.prototype.close = Path.prototype.closePath = function () {\n        this.commands.push({\n          type: "Z"\n        });\n      }, Path.prototype.extend = function (t) {\n        t.commands && (t = t.commands), Array.prototype.push.apply(this.commands, t);\n      }, Path.prototype.draw = function (t) {\n        t.beginPath();\n\n        for (var o = 0; o < this.commands.length; o += 1) {\n          var e = this.commands[o];\n          "M" === e.type ? t.moveTo(e.x, e.y) : "L" === e.type ? t.lineTo(e.x, e.y) : "C" === e.type ? t.bezierCurveTo(e.x1, e.y1, e.x2, e.y2, e.x, e.y) : "Q" === e.type ? t.quadraticCurveTo(e.x1, e.y1, e.x, e.y) : "Z" === e.type && t.closePath();\n        }\n\n        this.fill && (t.fillStyle = this.fill, t.fill()), this.stroke && (t.strokeStyle = this.stroke, t.lineWidth = this.strokeWidth, t.stroke());\n      }, Path.prototype.toPathData = function (t) {\n        function o(o) {\n          return Math.round(o) === o ? "" + Math.round(o) : o.toFixed(t);\n        }\n\n        function e() {\n          for (var t = "", e = 0; e < arguments.length; e += 1) {\n            var i = arguments[e];\n            i >= 0 && e > 0 && (t += " "), t += o(i);\n          }\n\n          return t;\n        }\n\n        t = void 0 !== t ? t : 2;\n\n        for (var i = "", s = 0; s < this.commands.length; s += 1) {\n          var h = this.commands[s];\n          "M" === h.type ? i += "M" + e(h.x, h.y) : "L" === h.type ? i += "L" + e(h.x, h.y) : "C" === h.type ? i += "C" + e(h.x1, h.y1, h.x2, h.y2, h.x, h.y) : "Q" === h.type ? i += "Q" + e(h.x1, h.y1, h.x, h.y) : "Z" === h.type && (i += "Z");\n        }\n\n        return i;\n      }, Path.prototype.toSVG = function (t) {\n        var o = \'<path d="\';\n        return o += this.toPathData(t), o += \'"\', this.fill && "black" !== this.fill && (o += null === this.fill ? \' fill="none"\' : \' fill="\' + this.fill + \'"\'), this.stroke && (o += \' stroke="\' + this.stroke + \'" stroke-width="\' + this.strokeWidth + \'"\'), o += "/>";\n      }, exports.Path = Path;\n    }, {}],\n    12: [function (require, module, exports) {\n      "use strict";\n\n      function arraysEqual(t, e) {\n        var r = t.length;\n        if (r !== e.length) return !1;\n\n        for (var a = 0; r > a; a++) {\n          if (t[a] !== e[a]) return !1;\n        }\n\n        return !0;\n      }\n\n      function getSubstFormat(t, e, r) {\n        for (var a = t.subtables, s = 0; s < a.length; s++) {\n          var o = a[s];\n          if (o.substFormat === e) return o;\n        }\n\n        return r ? (a.push(r), r) : void 0;\n      }\n\n      var check = require("./check"),\n          Layout = require("./layout"),\n          Substitution = function Substitution(t) {\n        this.font = t;\n      };\n\n      Substitution.prototype = Layout, Substitution.prototype.getGsubTable = function (t) {\n        var e = this.font.tables.gsub;\n        return !e && t && (this.font.tables.gsub = e = {\n          version: 1,\n          scripts: [{\n            tag: "DFLT",\n            script: {\n              defaultLangSys: {\n                reserved: 0,\n                reqFeatureIndex: 65535,\n                featureIndexes: []\n              },\n              langSysRecords: []\n            }\n          }],\n          features: [],\n          lookups: []\n        }), e;\n      }, Substitution.prototype.getSingle = function (t, e, r) {\n        var a = [],\n            s = this.getLookupTable(e, r, t, 1);\n        if (!s) return a;\n\n        for (var o = s.subtables, u = 0; u < o.length; u++) {\n          var i,\n              n = o[u],\n              g = this.expandCoverage(n.coverage);\n\n          if (1 === n.substFormat) {\n            var l = n.deltaGlyphId;\n\n            for (i = 0; i < g.length; i++) {\n              var c = g[i];\n              a.push({\n                sub: c,\n                by: c + l\n              });\n            }\n          } else {\n            var b = n.substitute;\n\n            for (i = 0; i < g.length; i++) {\n              a.push({\n                sub: g[i],\n                by: b[i]\n              });\n            }\n          }\n        }\n\n        return a;\n      }, Substitution.prototype.getAlternates = function (t, e, r) {\n        var a = [],\n            s = this.getLookupTable(e, r, t, 3);\n        if (!s) return a;\n\n        for (var o = s.subtables, u = 0; u < o.length; u++) {\n          for (var i = o[u], n = this.expandCoverage(i.coverage), g = i.alternateSets, l = 0; l < n.length; l++) {\n            a.push({\n              sub: n[l],\n              by: g[l]\n            });\n          }\n        }\n\n        return a;\n      }, Substitution.prototype.getLigatures = function (t, e, r) {\n        var a = [],\n            s = this.getLookupTable(e, r, t, 4);\n        if (!s) return [];\n\n        for (var o = s.subtables, u = 0; u < o.length; u++) {\n          for (var i = o[u], n = this.expandCoverage(i.coverage), g = i.ligatureSets, l = 0; l < n.length; l++) {\n            for (var c = n[l], b = g[l], h = 0; h < b.length; h++) {\n              var p = b[h];\n              a.push({\n                sub: [c].concat(p.components),\n                by: p.ligGlyph\n              });\n            }\n          }\n        }\n\n        return a;\n      }, Substitution.prototype.addSingle = function (t, e, r, a) {\n        var s = this.getLookupTable(r, a, t, 1, !0),\n            o = getSubstFormat(s, 2, {\n          substFormat: 2,\n          coverage: {\n            format: 1,\n            glyphs: []\n          },\n          substitute: []\n        });\n        check.assert(1 === o.coverage.format, "Ligature: unable to modify coverage table format " + o.coverage.format);\n        var u = e.sub,\n            i = this.binSearch(o.coverage.glyphs, u);\n        0 > i && (i = -1 - i, o.coverage.glyphs.splice(i, 0, u), o.substitute.splice(i, 0, 0)), o.substitute[i] = e.by;\n      }, Substitution.prototype.addAlternate = function (t, e, r, a) {\n        var s = this.getLookupTable(r, a, t, 3, !0),\n            o = getSubstFormat(s, 1, {\n          substFormat: 1,\n          coverage: {\n            format: 1,\n            glyphs: []\n          },\n          alternateSets: []\n        });\n        check.assert(1 === o.coverage.format, "Ligature: unable to modify coverage table format " + o.coverage.format);\n        var u = e.sub,\n            i = this.binSearch(o.coverage.glyphs, u);\n        0 > i && (i = -1 - i, o.coverage.glyphs.splice(i, 0, u), o.alternateSets.splice(i, 0, 0)), o.alternateSets[i] = e.by;\n      }, Substitution.prototype.addLigature = function (t, e, r, a) {\n        r = r || "DFLT", a = a || "DFLT";\n        var s = this.getLookupTable(r, a, t, 4, !0),\n            o = s.subtables[0];\n        o || (o = {\n          substFormat: 1,\n          coverage: {\n            format: 1,\n            glyphs: []\n          },\n          ligatureSets: []\n        }, s.subtables[0] = o), check.assert(1 === o.coverage.format, "Ligature: unable to modify coverage table format " + o.coverage.format);\n        var u = e.sub[0],\n            i = e.sub.slice(1),\n            n = {\n          ligGlyph: e.by,\n          components: i\n        },\n            g = this.binSearch(o.coverage.glyphs, u);\n\n        if (g >= 0) {\n          for (var l = o.ligatureSets[g], c = 0; c < l.length; c++) {\n            if (arraysEqual(l[c].components, i)) return;\n          }\n\n          l.push(n);\n        } else g = -1 - g, o.coverage.glyphs.splice(g, 0, u), o.ligatureSets.splice(g, 0, [n]);\n      }, Substitution.prototype.getFeature = function (t, e, r) {\n        if (e = e || "DFLT", r = r || "DFLT", /ss\\d\\d/.test(t)) return this.getSingle(t, e, r);\n\n        switch (t) {\n          case "aalt":\n          case "salt":\n            return this.getSingle(t, e, r).concat(this.getAlternates(t, e, r));\n\n          case "dlig":\n          case "liga":\n          case "rlig":\n            return this.getLigatures(t, e, r);\n        }\n      }, Substitution.prototype.add = function (t, e, r, a) {\n        if (r = r || "DFLT", a = a || "DFLT", /ss\\d\\d/.test(t)) return this.addSingle(t, e, r, a);\n\n        switch (t) {\n          case "aalt":\n          case "salt":\n            return "number" == typeof e.by ? this.addSingle(t, e, r, a) : this.addAlternate(t, e, r, a);\n\n          case "dlig":\n          case "liga":\n          case "rlig":\n            return this.addLigature(t, e, r, a);\n        }\n      }, module.exports = Substitution;\n    }, {\n      "./check": 2,\n      "./layout": 8\n    }],\n    13: [function (require, module, exports) {\n      "use strict";\n\n      function Table(e, t, a) {\n        var r;\n\n        for (r = 0; r < t.length; r += 1) {\n          var o = t[r];\n          this[o.name] = o.value;\n        }\n\n        if (this.tableName = e, this.fields = t, a) {\n          var s = Object.keys(a);\n\n          for (r = 0; r < s.length; r += 1) {\n            var n = s[r],\n                u = a[n];\n            void 0 !== this[n] && (this[n] = u);\n          }\n        }\n      }\n\n      function ushortList(e, t, a) {\n        void 0 === a && (a = t.length);\n        var r = new Array(t.length + 1);\n        r[0] = {\n          name: e + "Count",\n          type: "USHORT",\n          value: a\n        };\n\n        for (var o = 0; o < t.length; o++) {\n          r[o + 1] = {\n            name: e + o,\n            type: "USHORT",\n            value: t[o]\n          };\n        }\n\n        return r;\n      }\n\n      function tableList(e, t, a) {\n        var r = t.length,\n            o = new Array(r + 1);\n        o[0] = {\n          name: e + "Count",\n          type: "USHORT",\n          value: r\n        };\n\n        for (var s = 0; r > s; s++) {\n          o[s + 1] = {\n            name: e + s,\n            type: "TABLE",\n            value: a(t[s], s)\n          };\n        }\n\n        return o;\n      }\n\n      function recordList(e, t, a) {\n        var r = t.length,\n            o = [];\n        o[0] = {\n          name: e + "Count",\n          type: "USHORT",\n          value: r\n        };\n\n        for (var s = 0; r > s; s++) {\n          o = o.concat(a(t[s], s));\n        }\n\n        return o;\n      }\n\n      function Coverage(e) {\n        1 === e.format ? Table.call(this, "coverageTable", [{\n          name: "coverageFormat",\n          type: "USHORT",\n          value: 1\n        }].concat(ushortList("glyph", e.glyphs))) : check.assert(!1, "Can\'t create coverage table format 2 yet.");\n      }\n\n      function ScriptList(e) {\n        Table.call(this, "scriptListTable", recordList("scriptRecord", e, function (e, t) {\n          var a = e.script,\n              r = a.defaultLangSys;\n          return check.assert(!!r, "Unable to write GSUB: script " + e.tag + " has no default language system."), [{\n            name: "scriptTag" + t,\n            type: "TAG",\n            value: e.tag\n          }, {\n            name: "script" + t,\n            type: "TABLE",\n            value: new Table("scriptTable", [{\n              name: "defaultLangSys",\n              type: "TABLE",\n              value: new Table("defaultLangSys", [{\n                name: "lookupOrder",\n                type: "USHORT",\n                value: 0\n              }, {\n                name: "reqFeatureIndex",\n                type: "USHORT",\n                value: r.reqFeatureIndex\n              }].concat(ushortList("featureIndex", r.featureIndexes)))\n            }].concat(recordList("langSys", a.langSysRecords, function (e, t) {\n              var a = e.langSys;\n              return [{\n                name: "langSysTag" + t,\n                type: "TAG",\n                value: e.tag\n              }, {\n                name: "langSys" + t,\n                type: "TABLE",\n                value: new Table("langSys", [{\n                  name: "lookupOrder",\n                  type: "USHORT",\n                  value: 0\n                }, {\n                  name: "reqFeatureIndex",\n                  type: "USHORT",\n                  value: a.reqFeatureIndex\n                }].concat(ushortList("featureIndex", a.featureIndexes)))\n              }];\n            })))\n          }];\n        }));\n      }\n\n      function FeatureList(e) {\n        Table.call(this, "featureListTable", recordList("featureRecord", e, function (e, t) {\n          var a = e.feature;\n          return [{\n            name: "featureTag" + t,\n            type: "TAG",\n            value: e.tag\n          }, {\n            name: "feature" + t,\n            type: "TABLE",\n            value: new Table("featureTable", [{\n              name: "featureParams",\n              type: "USHORT",\n              value: a.featureParams\n            }].concat(ushortList("lookupListIndex", a.lookupListIndexes)))\n          }];\n        }));\n      }\n\n      function LookupList(e, t) {\n        Table.call(this, "lookupListTable", tableList("lookup", e, function (e) {\n          var a = t[e.lookupType];\n          return check.assert(!!a, "Unable to write GSUB lookup type " + e.lookupType + " tables."), new Table("lookupTable", [{\n            name: "lookupType",\n            type: "USHORT",\n            value: e.lookupType\n          }, {\n            name: "lookupFlag",\n            type: "USHORT",\n            value: e.lookupFlag\n          }].concat(tableList("subtable", e.subtables, a)));\n        }));\n      }\n\n      var check = require("./check"),\n          encode = require("./types").encode,\n          sizeOf = require("./types").sizeOf;\n\n      Table.prototype.encode = function () {\n        return encode.TABLE(this);\n      }, Table.prototype.sizeOf = function () {\n        return sizeOf.TABLE(this);\n      }, Coverage.prototype = Object.create(Table.prototype), Coverage.prototype.constructor = Coverage, ScriptList.prototype = Object.create(Table.prototype), ScriptList.prototype.constructor = ScriptList, FeatureList.prototype = Object.create(Table.prototype), FeatureList.prototype.constructor = FeatureList, LookupList.prototype = Object.create(Table.prototype), LookupList.prototype.constructor = LookupList, exports.Record = exports.Table = Table, exports.Coverage = Coverage, exports.ScriptList = ScriptList, exports.FeatureList = FeatureList, exports.LookupList = LookupList, exports.ushortList = ushortList, exports.tableList = tableList, exports.recordList = recordList;\n    }, {\n      "./check": 2,\n      "./types": 32\n    }],\n    14: [function (require, module, exports) {\n      "use strict";\n\n      function equals(e, t) {\n        if (e === t) return !0;\n\n        if (Array.isArray(e) && Array.isArray(t)) {\n          if (e.length !== t.length) return !1;\n\n          for (var a = 0; a < e.length; a += 1) {\n            if (!equals(e[a], t[a])) return !1;\n          }\n\n          return !0;\n        }\n\n        return !1;\n      }\n\n      function parseCFFIndex(e, t, a) {\n        var r,\n            n,\n            s,\n            i = [],\n            o = [],\n            h = parse.getCard16(e, t);\n\n        if (0 !== h) {\n          var f = parse.getByte(e, t + 2);\n          n = t + (h + 1) * f + 2;\n          var p = t + 3;\n\n          for (r = 0; h + 1 > r; r += 1) {\n            i.push(parse.getOffset(e, p, f)), p += f;\n          }\n\n          s = n + i[h];\n        } else s = t + 2;\n\n        for (r = 0; r < i.length - 1; r += 1) {\n          var u = parse.getBytes(e, n + i[r], n + i[r + 1]);\n          a && (u = a(u)), o.push(u);\n        }\n\n        return {\n          objects: o,\n          startOffset: t,\n          endOffset: s\n        };\n      }\n\n      function parseFloatOperand(e) {\n        for (var t = "", a = 15, r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];;) {\n          var n = e.parseByte(),\n              s = n >> 4,\n              i = 15 & n;\n          if (s === a) break;\n          if (t += r[s], i === a) break;\n          t += r[i];\n        }\n\n        return parseFloat(t);\n      }\n\n      function parseOperand(e, t) {\n        var a, r, n, s;\n        if (28 === t) return a = e.parseByte(), r = e.parseByte(), a << 8 | r;\n        if (29 === t) return a = e.parseByte(), r = e.parseByte(), n = e.parseByte(), s = e.parseByte(), a << 24 | r << 16 | n << 8 | s;\n        if (30 === t) return parseFloatOperand(e);\n        if (t >= 32 && 246 >= t) return t - 139;\n        if (t >= 247 && 250 >= t) return a = e.parseByte(), 256 * (t - 247) + a + 108;\n        if (t >= 251 && 254 >= t) return a = e.parseByte(), 256 * -(t - 251) - a - 108;\n        throw new Error("Invalid b0 " + t);\n      }\n\n      function entriesToObject(e) {\n        for (var t = {}, a = 0; a < e.length; a += 1) {\n          var r,\n              n = e[a][0],\n              s = e[a][1];\n          if (r = 1 === s.length ? s[0] : s, t.hasOwnProperty(n)) throw new Error("Object " + t + " already has key " + n);\n          t[n] = r;\n        }\n\n        return t;\n      }\n\n      function parseCFFDict(e, t, a) {\n        t = void 0 !== t ? t : 0;\n        var r = new parse.Parser(e, t),\n            n = [],\n            s = [];\n\n        for (a = void 0 !== a ? a : e.length; r.relativeOffset < a;) {\n          var i = r.parseByte();\n          21 >= i ? (12 === i && (i = 1200 + r.parseByte()), n.push([i, s]), s = []) : s.push(parseOperand(r, i));\n        }\n\n        return entriesToObject(n);\n      }\n\n      function getCFFString(e, t) {\n        return t = 390 >= t ? encoding.cffStandardStrings[t] : e[t - 391];\n      }\n\n      function interpretDict(e, t, a) {\n        for (var r = {}, n = 0; n < t.length; n += 1) {\n          var s = t[n],\n              i = e[s.op];\n          void 0 === i && (i = void 0 !== s.value ? s.value : null), "SID" === s.type && (i = getCFFString(a, i)), r[s.name] = i;\n        }\n\n        return r;\n      }\n\n      function parseCFFHeader(e, t) {\n        var a = {};\n        return a.formatMajor = parse.getCard8(e, t), a.formatMinor = parse.getCard8(e, t + 1), a.size = parse.getCard8(e, t + 2), a.offsetSize = parse.getCard8(e, t + 3), a.startOffset = t, a.endOffset = t + 4, a;\n      }\n\n      function parseCFFTopDict(e, t) {\n        var a = parseCFFDict(e, 0, e.byteLength);\n        return interpretDict(a, TOP_DICT_META, t);\n      }\n\n      function parseCFFPrivateDict(e, t, a, r) {\n        var n = parseCFFDict(e, t, a);\n        return interpretDict(n, PRIVATE_DICT_META, r);\n      }\n\n      function parseCFFCharset(e, t, a, r) {\n        var n,\n            s,\n            i,\n            o = new parse.Parser(e, t);\n        a -= 1;\n        var h = [".notdef"],\n            f = o.parseCard8();\n        if (0 === f) for (n = 0; a > n; n += 1) {\n          s = o.parseSID(), h.push(getCFFString(r, s));\n        } else if (1 === f) for (; h.length <= a;) {\n          for (s = o.parseSID(), i = o.parseCard8(), n = 0; i >= n; n += 1) {\n            h.push(getCFFString(r, s)), s += 1;\n          }\n        } else {\n          if (2 !== f) throw new Error("Unknown charset format " + f);\n\n          for (; h.length <= a;) {\n            for (s = o.parseSID(), i = o.parseCard16(), n = 0; i >= n; n += 1) {\n              h.push(getCFFString(r, s)), s += 1;\n            }\n          }\n        }\n        return h;\n      }\n\n      function parseCFFEncoding(e, t, a) {\n        var r,\n            n,\n            s = {},\n            i = new parse.Parser(e, t),\n            o = i.parseCard8();\n\n        if (0 === o) {\n          var h = i.parseCard8();\n\n          for (r = 0; h > r; r += 1) {\n            n = i.parseCard8(), s[n] = r;\n          }\n        } else {\n          if (1 !== o) throw new Error("Unknown encoding format " + o);\n          var f = i.parseCard8();\n\n          for (n = 1, r = 0; f > r; r += 1) {\n            for (var p = i.parseCard8(), u = i.parseCard8(), l = p; p + u >= l; l += 1) {\n              s[l] = n, n += 1;\n            }\n          }\n        }\n\n        return new encoding.CffEncoding(s, a);\n      }\n\n      function parseCFFCharstring(e, t, a) {\n        function r(e, t) {\n          g && p.closePath(), p.moveTo(e, t), g = !0;\n        }\n\n        function n() {\n          var t;\n          t = u.length % 2 !== 0, t && !c && (d = u.shift() + e.nominalWidthX), l += u.length >> 1, u.length = 0, c = !0;\n        }\n\n        function s(a) {\n          for (var y, b, C, T, F, I, D, x, k, S, E, O, R = 0; R < a.length;) {\n            var M = a[R];\n\n            switch (R += 1, M) {\n              case 1:\n                n();\n                break;\n\n              case 3:\n                n();\n                break;\n\n              case 4:\n                u.length > 1 && !c && (d = u.shift() + e.nominalWidthX, c = !0), m += u.pop(), r(v, m);\n                break;\n\n              case 5:\n                for (; u.length > 0;) {\n                  v += u.shift(), m += u.shift(), p.lineTo(v, m);\n                }\n\n                break;\n\n              case 6:\n                for (; u.length > 0 && (v += u.shift(), p.lineTo(v, m), 0 !== u.length);) {\n                  m += u.shift(), p.lineTo(v, m);\n                }\n\n                break;\n\n              case 7:\n                for (; u.length > 0 && (m += u.shift(), p.lineTo(v, m), 0 !== u.length);) {\n                  v += u.shift(), p.lineTo(v, m);\n                }\n\n                break;\n\n              case 8:\n                for (; u.length > 0;) {\n                  i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f + u.shift(), p.curveTo(i, o, h, f, v, m);\n                }\n\n                break;\n\n              case 10:\n                F = u.pop() + e.subrsBias, I = e.subrs[F], I && s(I);\n                break;\n\n              case 11:\n                return;\n\n              case 12:\n                switch (M = a[R], R += 1, M) {\n                  case 35:\n                    i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), D = h + u.shift(), x = f + u.shift(), k = D + u.shift(), S = x + u.shift(), E = k + u.shift(), O = S + u.shift(), v = E + u.shift(), m = O + u.shift(), u.shift(), p.curveTo(i, o, h, f, D, x), p.curveTo(k, S, E, O, v, m);\n                    break;\n\n                  case 34:\n                    i = v + u.shift(), o = m, h = i + u.shift(), f = o + u.shift(), D = h + u.shift(), x = f, k = D + u.shift(), S = f, E = k + u.shift(), O = m, v = E + u.shift(), p.curveTo(i, o, h, f, D, x), p.curveTo(k, S, E, O, v, m);\n                    break;\n\n                  case 36:\n                    i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), D = h + u.shift(), x = f, k = D + u.shift(), S = f, E = k + u.shift(), O = S + u.shift(), v = E + u.shift(), p.curveTo(i, o, h, f, D, x), p.curveTo(k, S, E, O, v, m);\n                    break;\n\n                  case 37:\n                    i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), D = h + u.shift(), x = f + u.shift(), k = D + u.shift(), S = x + u.shift(), E = k + u.shift(), O = S + u.shift(), Math.abs(E - v) > Math.abs(O - m) ? v = E + u.shift() : m = O + u.shift(), p.curveTo(i, o, h, f, D, x), p.curveTo(k, S, E, O, v, m);\n                    break;\n\n                  default:\n                    console.log("Glyph " + t.index + ": unknown operator 1200" + M), u.length = 0;\n                }\n\n                break;\n\n              case 14:\n                u.length > 0 && !c && (d = u.shift() + e.nominalWidthX, c = !0), g && (p.closePath(), g = !1);\n                break;\n\n              case 18:\n                n();\n                break;\n\n              case 19:\n              case 20:\n                n(), R += l + 7 >> 3;\n                break;\n\n              case 21:\n                u.length > 2 && !c && (d = u.shift() + e.nominalWidthX, c = !0), m += u.pop(), v += u.pop(), r(v, m);\n                break;\n\n              case 22:\n                u.length > 1 && !c && (d = u.shift() + e.nominalWidthX, c = !0), v += u.pop(), r(v, m);\n                break;\n\n              case 23:\n                n();\n                break;\n\n              case 24:\n                for (; u.length > 2;) {\n                  i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f + u.shift(), p.curveTo(i, o, h, f, v, m);\n                }\n\n                v += u.shift(), m += u.shift(), p.lineTo(v, m);\n                break;\n\n              case 25:\n                for (; u.length > 6;) {\n                  v += u.shift(), m += u.shift(), p.lineTo(v, m);\n                }\n\n                i = v + u.shift(), o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f + u.shift(), p.curveTo(i, o, h, f, v, m);\n                break;\n\n              case 26:\n                for (u.length % 2 && (v += u.shift()); u.length > 0;) {\n                  i = v, o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h, m = f + u.shift(), p.curveTo(i, o, h, f, v, m);\n                }\n\n                break;\n\n              case 27:\n                for (u.length % 2 && (m += u.shift()); u.length > 0;) {\n                  i = v + u.shift(), o = m, h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f, p.curveTo(i, o, h, f, v, m);\n                }\n\n                break;\n\n              case 28:\n                y = a[R], b = a[R + 1], u.push((y << 24 | b << 16) >> 16), R += 2;\n                break;\n\n              case 29:\n                F = u.pop() + e.gsubrsBias, I = e.gsubrs[F], I && s(I);\n                break;\n\n              case 30:\n                for (; u.length > 0 && (i = v, o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f + (1 === u.length ? u.shift() : 0), p.curveTo(i, o, h, f, v, m), 0 !== u.length);) {\n                  i = v + u.shift(), o = m, h = i + u.shift(), f = o + u.shift(), m = f + u.shift(), v = h + (1 === u.length ? u.shift() : 0), p.curveTo(i, o, h, f, v, m);\n                }\n\n                break;\n\n              case 31:\n                for (; u.length > 0 && (i = v + u.shift(), o = m, h = i + u.shift(), f = o + u.shift(), m = f + u.shift(), v = h + (1 === u.length ? u.shift() : 0), p.curveTo(i, o, h, f, v, m), 0 !== u.length);) {\n                  i = v, o = m + u.shift(), h = i + u.shift(), f = o + u.shift(), v = h + u.shift(), m = f + (1 === u.length ? u.shift() : 0), p.curveTo(i, o, h, f, v, m);\n                }\n\n                break;\n\n              default:\n                32 > M ? console.log("Glyph " + t.index + ": unknown operator " + M) : 247 > M ? u.push(M - 139) : 251 > M ? (y = a[R], R += 1, u.push(256 * (M - 247) + y + 108)) : 255 > M ? (y = a[R], R += 1, u.push(256 * -(M - 251) - y - 108)) : (y = a[R], b = a[R + 1], C = a[R + 2], T = a[R + 3], R += 4, u.push((y << 24 | b << 16 | C << 8 | T) / 65536));\n            }\n          }\n        }\n\n        var i,\n            o,\n            h,\n            f,\n            p = new path.Path(),\n            u = [],\n            l = 0,\n            c = !1,\n            d = e.defaultWidthX,\n            g = !1,\n            v = 0,\n            m = 0;\n        return s(a), t.advanceWidth = d, p;\n      }\n\n      function calcCFFSubroutineBias(e) {\n        var t;\n        return t = e.length < 1240 ? 107 : e.length < 33900 ? 1131 : 32768;\n      }\n\n      function parseCFFTable(e, t, a) {\n        a.tables.cff = {};\n        var r = parseCFFHeader(e, t),\n            n = parseCFFIndex(e, r.endOffset, parse.bytesToString),\n            s = parseCFFIndex(e, n.endOffset),\n            i = parseCFFIndex(e, s.endOffset, parse.bytesToString),\n            o = parseCFFIndex(e, i.endOffset);\n        a.gsubrs = o.objects, a.gsubrsBias = calcCFFSubroutineBias(a.gsubrs);\n        var h = new DataView(new Uint8Array(s.objects[0]).buffer),\n            f = parseCFFTopDict(h, i.objects);\n        a.tables.cff.topDict = f;\n        var p = t + f["private"][1],\n            u = parseCFFPrivateDict(e, p, f["private"][0], i.objects);\n\n        if (a.defaultWidthX = u.defaultWidthX, a.nominalWidthX = u.nominalWidthX, 0 !== u.subrs) {\n          var l = p + u.subrs,\n              c = parseCFFIndex(e, l);\n          a.subrs = c.objects, a.subrsBias = calcCFFSubroutineBias(a.subrs);\n        } else a.subrs = [], a.subrsBias = 0;\n\n        var d = parseCFFIndex(e, t + f.charStrings);\n        a.nGlyphs = d.objects.length;\n        var g = parseCFFCharset(e, t + f.charset, a.nGlyphs, i.objects);\n        a.cffEncoding = 0 === f.encoding ? new encoding.CffEncoding(encoding.cffStandardEncoding, g) : 1 === f.encoding ? new encoding.CffEncoding(encoding.cffExpertEncoding, g) : parseCFFEncoding(e, t + f.encoding, g), a.encoding = a.encoding || a.cffEncoding, a.glyphs = new glyphset.GlyphSet(a);\n\n        for (var v = 0; v < a.nGlyphs; v += 1) {\n          var m = d.objects[v];\n          a.glyphs.push(v, glyphset.cffGlyphLoader(a, v, parseCFFCharstring, m));\n        }\n      }\n\n      function encodeString(e, t) {\n        var a,\n            r = encoding.cffStandardStrings.indexOf(e);\n        return r >= 0 && (a = r), r = t.indexOf(e), r >= 0 ? a = r + encoding.cffStandardStrings.length : (a = encoding.cffStandardStrings.length + t.length, t.push(e)), a;\n      }\n\n      function makeHeader() {\n        return new table.Record("Header", [{\n          name: "major",\n          type: "Card8",\n          value: 1\n        }, {\n          name: "minor",\n          type: "Card8",\n          value: 0\n        }, {\n          name: "hdrSize",\n          type: "Card8",\n          value: 4\n        }, {\n          name: "major",\n          type: "Card8",\n          value: 1\n        }]);\n      }\n\n      function makeNameIndex(e) {\n        var t = new table.Record("Name INDEX", [{\n          name: "names",\n          type: "INDEX",\n          value: []\n        }]);\n        t.names = [];\n\n        for (var a = 0; a < e.length; a += 1) {\n          t.names.push({\n            name: "name_" + a,\n            type: "NAME",\n            value: e[a]\n          });\n        }\n\n        return t;\n      }\n\n      function makeDict(e, t, a) {\n        for (var r = {}, n = 0; n < e.length; n += 1) {\n          var s = e[n],\n              i = t[s.name];\n          void 0 === i || equals(i, s.value) || ("SID" === s.type && (i = encodeString(i, a)), r[s.op] = {\n            name: s.name,\n            type: s.type,\n            value: i\n          });\n        }\n\n        return r;\n      }\n\n      function makeTopDict(e, t) {\n        var a = new table.Record("Top DICT", [{\n          name: "dict",\n          type: "DICT",\n          value: {}\n        }]);\n        return a.dict = makeDict(TOP_DICT_META, e, t), a;\n      }\n\n      function makeTopDictIndex(e) {\n        var t = new table.Record("Top DICT INDEX", [{\n          name: "topDicts",\n          type: "INDEX",\n          value: []\n        }]);\n        return t.topDicts = [{\n          name: "topDict_0",\n          type: "TABLE",\n          value: e\n        }], t;\n      }\n\n      function makeStringIndex(e) {\n        var t = new table.Record("String INDEX", [{\n          name: "strings",\n          type: "INDEX",\n          value: []\n        }]);\n        t.strings = [];\n\n        for (var a = 0; a < e.length; a += 1) {\n          t.strings.push({\n            name: "string_" + a,\n            type: "STRING",\n            value: e[a]\n          });\n        }\n\n        return t;\n      }\n\n      function makeGlobalSubrIndex() {\n        return new table.Record("Global Subr INDEX", [{\n          name: "subrs",\n          type: "INDEX",\n          value: []\n        }]);\n      }\n\n      function makeCharsets(e, t) {\n        for (var a = new table.Record("Charsets", [{\n          name: "format",\n          type: "Card8",\n          value: 0\n        }]), r = 0; r < e.length; r += 1) {\n          var n = e[r],\n              s = encodeString(n, t);\n          a.fields.push({\n            name: "glyph_" + r,\n            type: "SID",\n            value: s\n          });\n        }\n\n        return a;\n      }\n\n      function glyphToOps(e) {\n        var t = [],\n            a = e.path;\n        t.push({\n          name: "width",\n          type: "NUMBER",\n          value: e.advanceWidth\n        });\n\n        for (var r = 0, n = 0, s = 0; s < a.commands.length; s += 1) {\n          var i,\n              o,\n              h = a.commands[s];\n\n          if ("Q" === h.type) {\n            var f = 1 / 3,\n                p = 2 / 3;\n            h = {\n              type: "C",\n              x: h.x,\n              y: h.y,\n              x1: f * r + p * h.x1,\n              y1: f * n + p * h.y1,\n              x2: f * h.x + p * h.x1,\n              y2: f * h.y + p * h.y1\n            };\n          }\n\n          if ("M" === h.type) i = Math.round(h.x - r), o = Math.round(h.y - n), t.push({\n            name: "dx",\n            type: "NUMBER",\n            value: i\n          }), t.push({\n            name: "dy",\n            type: "NUMBER",\n            value: o\n          }), t.push({\n            name: "rmoveto",\n            type: "OP",\n            value: 21\n          }), r = Math.round(h.x), n = Math.round(h.y);else if ("L" === h.type) i = Math.round(h.x - r), o = Math.round(h.y - n), t.push({\n            name: "dx",\n            type: "NUMBER",\n            value: i\n          }), t.push({\n            name: "dy",\n            type: "NUMBER",\n            value: o\n          }), t.push({\n            name: "rlineto",\n            type: "OP",\n            value: 5\n          }), r = Math.round(h.x), n = Math.round(h.y);else if ("C" === h.type) {\n            var u = Math.round(h.x1 - r),\n                l = Math.round(h.y1 - n),\n                c = Math.round(h.x2 - h.x1),\n                d = Math.round(h.y2 - h.y1);\n            i = Math.round(h.x - h.x2), o = Math.round(h.y - h.y2), t.push({\n              name: "dx1",\n              type: "NUMBER",\n              value: u\n            }), t.push({\n              name: "dy1",\n              type: "NUMBER",\n              value: l\n            }), t.push({\n              name: "dx2",\n              type: "NUMBER",\n              value: c\n            }), t.push({\n              name: "dy2",\n              type: "NUMBER",\n              value: d\n            }), t.push({\n              name: "dx",\n              type: "NUMBER",\n              value: i\n            }), t.push({\n              name: "dy",\n              type: "NUMBER",\n              value: o\n            }), t.push({\n              name: "rrcurveto",\n              type: "OP",\n              value: 8\n            }), r = Math.round(h.x), n = Math.round(h.y);\n          }\n        }\n\n        return t.push({\n          name: "endchar",\n          type: "OP",\n          value: 14\n        }), t;\n      }\n\n      function makeCharStringsIndex(e) {\n        for (var t = new table.Record("CharStrings INDEX", [{\n          name: "charStrings",\n          type: "INDEX",\n          value: []\n        }]), a = 0; a < e.length; a += 1) {\n          var r = e.get(a),\n              n = glyphToOps(r);\n          t.charStrings.push({\n            name: r.name,\n            type: "CHARSTRING",\n            value: n\n          });\n        }\n\n        return t;\n      }\n\n      function makePrivateDict(e, t) {\n        var a = new table.Record("Private DICT", [{\n          name: "dict",\n          type: "DICT",\n          value: {}\n        }]);\n        return a.dict = makeDict(PRIVATE_DICT_META, e, t), a;\n      }\n\n      function makeCFFTable(e, t) {\n        for (var a, r = new table.Table("CFF ", [{\n          name: "header",\n          type: "RECORD"\n        }, {\n          name: "nameIndex",\n          type: "RECORD"\n        }, {\n          name: "topDictIndex",\n          type: "RECORD"\n        }, {\n          name: "stringIndex",\n          type: "RECORD"\n        }, {\n          name: "globalSubrIndex",\n          type: "RECORD"\n        }, {\n          name: "charsets",\n          type: "RECORD"\n        }, {\n          name: "charStringsIndex",\n          type: "RECORD"\n        }, {\n          name: "privateDict",\n          type: "RECORD"\n        }]), n = 1 / t.unitsPerEm, s = {\n          version: t.version,\n          fullName: t.fullName,\n          familyName: t.familyName,\n          weight: t.weightName,\n          fontBBox: t.fontBBox || [0, 0, 0, 0],\n          fontMatrix: [n, 0, 0, n, 0, 0],\n          charset: 999,\n          encoding: 0,\n          charStrings: 999,\n          "private": [0, 999]\n        }, i = {}, o = [], h = 1; h < e.length; h += 1) {\n          a = e.get(h), o.push(a.name);\n        }\n\n        var f = [];\n        r.header = makeHeader(), r.nameIndex = makeNameIndex([t.postScriptName]);\n        var p = makeTopDict(s, f);\n        r.topDictIndex = makeTopDictIndex(p), r.globalSubrIndex = makeGlobalSubrIndex(), r.charsets = makeCharsets(o, f), r.charStringsIndex = makeCharStringsIndex(e), r.privateDict = makePrivateDict(i, f), r.stringIndex = makeStringIndex(f);\n        var u = r.header.sizeOf() + r.nameIndex.sizeOf() + r.topDictIndex.sizeOf() + r.stringIndex.sizeOf() + r.globalSubrIndex.sizeOf();\n        return s.charset = u, s.encoding = 0, s.charStrings = s.charset + r.charsets.sizeOf(), s["private"][1] = s.charStrings + r.charStringsIndex.sizeOf(), p = makeTopDict(s, f), r.topDictIndex = makeTopDictIndex(p), r;\n      }\n\n      var encoding = require("../encoding"),\n          glyphset = require("../glyphset"),\n          parse = require("../parse"),\n          path = require("../path"),\n          table = require("../table"),\n          TOP_DICT_META = [{\n        name: "version",\n        op: 0,\n        type: "SID"\n      }, {\n        name: "notice",\n        op: 1,\n        type: "SID"\n      }, {\n        name: "copyright",\n        op: 1200,\n        type: "SID"\n      }, {\n        name: "fullName",\n        op: 2,\n        type: "SID"\n      }, {\n        name: "familyName",\n        op: 3,\n        type: "SID"\n      }, {\n        name: "weight",\n        op: 4,\n        type: "SID"\n      }, {\n        name: "isFixedPitch",\n        op: 1201,\n        type: "number",\n        value: 0\n      }, {\n        name: "italicAngle",\n        op: 1202,\n        type: "number",\n        value: 0\n      }, {\n        name: "underlinePosition",\n        op: 1203,\n        type: "number",\n        value: -100\n      }, {\n        name: "underlineThickness",\n        op: 1204,\n        type: "number",\n        value: 50\n      }, {\n        name: "paintType",\n        op: 1205,\n        type: "number",\n        value: 0\n      }, {\n        name: "charstringType",\n        op: 1206,\n        type: "number",\n        value: 2\n      }, {\n        name: "fontMatrix",\n        op: 1207,\n        type: ["real", "real", "real", "real", "real", "real"],\n        value: [.001, 0, 0, .001, 0, 0]\n      }, {\n        name: "uniqueId",\n        op: 13,\n        type: "number"\n      }, {\n        name: "fontBBox",\n        op: 5,\n        type: ["number", "number", "number", "number"],\n        value: [0, 0, 0, 0]\n      }, {\n        name: "strokeWidth",\n        op: 1208,\n        type: "number",\n        value: 0\n      }, {\n        name: "xuid",\n        op: 14,\n        type: [],\n        value: null\n      }, {\n        name: "charset",\n        op: 15,\n        type: "offset",\n        value: 0\n      }, {\n        name: "encoding",\n        op: 16,\n        type: "offset",\n        value: 0\n      }, {\n        name: "charStrings",\n        op: 17,\n        type: "offset",\n        value: 0\n      }, {\n        name: "private",\n        op: 18,\n        type: ["number", "offset"],\n        value: [0, 0]\n      }],\n          PRIVATE_DICT_META = [{\n        name: "subrs",\n        op: 19,\n        type: "offset",\n        value: 0\n      }, {\n        name: "defaultWidthX",\n        op: 20,\n        type: "number",\n        value: 0\n      }, {\n        name: "nominalWidthX",\n        op: 21,\n        type: "number",\n        value: 0\n      }];\n\n      exports.parse = parseCFFTable, exports.make = makeCFFTable;\n    }, {\n      "../encoding": 4,\n      "../glyphset": 7,\n      "../parse": 10,\n      "../path": 11,\n      "../table": 13\n    }],\n    15: [function (require, module, exports) {\n      "use strict";\n\n      function parseCmapTableFormat12(e, a) {\n        var r;\n        a.parseUShort(), e.length = a.parseULong(), e.language = a.parseULong();\n        var t;\n\n        for (e.groupCount = t = a.parseULong(), e.glyphIndexMap = {}, r = 0; t > r; r += 1) {\n          for (var n = a.parseULong(), s = a.parseULong(), o = a.parseULong(), l = n; s >= l; l += 1) {\n            e.glyphIndexMap[l] = o, o++;\n          }\n        }\n      }\n\n      function parseCmapTableFormat4(e, a, r, t, n) {\n        var s;\n        e.length = a.parseUShort(), e.language = a.parseUShort();\n        var o;\n        e.segCount = o = a.parseUShort() >> 1, a.skip("uShort", 3), e.glyphIndexMap = {};\n        var l = new parse.Parser(r, t + n + 14),\n            p = new parse.Parser(r, t + n + 16 + 2 * o),\n            g = new parse.Parser(r, t + n + 16 + 4 * o),\n            m = new parse.Parser(r, t + n + 16 + 6 * o),\n            u = t + n + 16 + 8 * o;\n\n        for (s = 0; o - 1 > s; s += 1) {\n          for (var h, f = l.parseUShort(), c = p.parseUShort(), d = g.parseShort(), i = m.parseUShort(), v = c; f >= v; v += 1) {\n            0 !== i ? (u = m.offset + m.relativeOffset - 2, u += i, u += 2 * (v - c), h = parse.getUShort(r, u), 0 !== h && (h = h + d & 65535)) : h = v + d & 65535, e.glyphIndexMap[v] = h;\n          }\n        }\n      }\n\n      function parseCmapTable(e, a) {\n        var r,\n            t = {};\n        t.version = parse.getUShort(e, a), check.argument(0 === t.version, "cmap table version should be 0."), t.numTables = parse.getUShort(e, a + 2);\n        var n = -1;\n\n        for (r = t.numTables - 1; r >= 0; r -= 1) {\n          var s = parse.getUShort(e, a + 4 + 8 * r),\n              o = parse.getUShort(e, a + 4 + 8 * r + 2);\n\n          if (3 === s && (0 === o || 1 === o || 10 === o)) {\n            n = parse.getULong(e, a + 4 + 8 * r + 4);\n            break;\n          }\n        }\n\n        if (-1 === n) return null;\n        var l = new parse.Parser(e, a + n);\n        if (t.format = l.parseUShort(), 12 === t.format) parseCmapTableFormat12(t, l);else {\n          if (4 !== t.format) throw new Error("Only format 4 and 12 cmap tables are supported.");\n          parseCmapTableFormat4(t, l, e, a, n);\n        }\n        return t;\n      }\n\n      function addSegment(e, a, r) {\n        e.segments.push({\n          end: a,\n          start: a,\n          delta: -(a - r),\n          offset: 0\n        });\n      }\n\n      function addTerminatorSegment(e) {\n        e.segments.push({\n          end: 65535,\n          start: 65535,\n          delta: 1,\n          offset: 0\n        });\n      }\n\n      function makeCmapTable(e) {\n        var a,\n            r = new table.Table("cmap", [{\n          name: "version",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "numTables",\n          type: "USHORT",\n          value: 1\n        }, {\n          name: "platformID",\n          type: "USHORT",\n          value: 3\n        }, {\n          name: "encodingID",\n          type: "USHORT",\n          value: 1\n        }, {\n          name: "offset",\n          type: "ULONG",\n          value: 12\n        }, {\n          name: "format",\n          type: "USHORT",\n          value: 4\n        }, {\n          name: "length",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "language",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "segCountX2",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "searchRange",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "entrySelector",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "rangeShift",\n          type: "USHORT",\n          value: 0\n        }]);\n\n        for (r.segments = [], a = 0; a < e.length; a += 1) {\n          for (var t = e.get(a), n = 0; n < t.unicodes.length; n += 1) {\n            addSegment(r, t.unicodes[n], a);\n          }\n\n          r.segments = r.segments.sort(function (e, a) {\n            return e.start - a.start;\n          });\n        }\n\n        addTerminatorSegment(r);\n        var s;\n        s = r.segments.length, r.segCountX2 = 2 * s, r.searchRange = 2 * Math.pow(2, Math.floor(Math.log(s) / Math.log(2))), r.entrySelector = Math.log(r.searchRange / 2) / Math.log(2), r.rangeShift = r.segCountX2 - r.searchRange;\n        var o = [],\n            l = [],\n            p = [],\n            g = [],\n            m = [];\n\n        for (a = 0; s > a; a += 1) {\n          var u = r.segments[a];\n          o = o.concat({\n            name: "end_" + a,\n            type: "USHORT",\n            value: u.end\n          }), l = l.concat({\n            name: "start_" + a,\n            type: "USHORT",\n            value: u.start\n          }), p = p.concat({\n            name: "idDelta_" + a,\n            type: "SHORT",\n            value: u.delta\n          }), g = g.concat({\n            name: "idRangeOffset_" + a,\n            type: "USHORT",\n            value: u.offset\n          }), void 0 !== u.glyphId && (m = m.concat({\n            name: "glyph_" + a,\n            type: "USHORT",\n            value: u.glyphId\n          }));\n        }\n\n        return r.fields = r.fields.concat(o), r.fields.push({\n          name: "reservedPad",\n          type: "USHORT",\n          value: 0\n        }), r.fields = r.fields.concat(l), r.fields = r.fields.concat(p), r.fields = r.fields.concat(g), r.fields = r.fields.concat(m), r.length = 14 + 2 * o.length + 2 + 2 * l.length + 2 * p.length + 2 * g.length + 2 * m.length, r;\n      }\n\n      var check = require("../check"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseCmapTable, exports.make = makeCmapTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13\n    }],\n    16: [function (require, module, exports) {\n      "use strict";\n\n      function addName(e, a) {\n        var r = JSON.stringify(e),\n            n = 256;\n\n        for (var t in a) {\n          var s = parseInt(t);\n\n          if (s && !(256 > s)) {\n            if (JSON.stringify(a[t]) === r) return s;\n            s >= n && (n = s + 1);\n          }\n        }\n\n        return a[n] = e, n;\n      }\n\n      function makeFvarAxis(e, a, r) {\n        var n = addName(a.name, r);\n        return [{\n          name: "tag_" + e,\n          type: "TAG",\n          value: a.tag\n        }, {\n          name: "minValue_" + e,\n          type: "FIXED",\n          value: a.minValue << 16\n        }, {\n          name: "defaultValue_" + e,\n          type: "FIXED",\n          value: a.defaultValue << 16\n        }, {\n          name: "maxValue_" + e,\n          type: "FIXED",\n          value: a.maxValue << 16\n        }, {\n          name: "flags_" + e,\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "nameID_" + e,\n          type: "USHORT",\n          value: n\n        }];\n      }\n\n      function parseFvarAxis(e, a, r) {\n        var n = {},\n            t = new parse.Parser(e, a);\n        return n.tag = t.parseTag(), n.minValue = t.parseFixed(), n.defaultValue = t.parseFixed(), n.maxValue = t.parseFixed(), t.skip("uShort", 1), n.name = r[t.parseUShort()] || {}, n;\n      }\n\n      function makeFvarInstance(e, a, r, n) {\n        for (var t = addName(a.name, n), s = [{\n          name: "nameID_" + e,\n          type: "USHORT",\n          value: t\n        }, {\n          name: "flags_" + e,\n          type: "USHORT",\n          value: 0\n        }], u = 0; u < r.length; ++u) {\n          var i = r[u].tag;\n          s.push({\n            name: "axis_" + e + " " + i,\n            type: "FIXED",\n            value: a.coordinates[i] << 16\n          });\n        }\n\n        return s;\n      }\n\n      function parseFvarInstance(e, a, r, n) {\n        var t = {},\n            s = new parse.Parser(e, a);\n        t.name = n[s.parseUShort()] || {}, s.skip("uShort", 1), t.coordinates = {};\n\n        for (var u = 0; u < r.length; ++u) {\n          t.coordinates[r[u].tag] = s.parseFixed();\n        }\n\n        return t;\n      }\n\n      function makeFvarTable(e, a) {\n        var r = new table.Table("fvar", [{\n          name: "version",\n          type: "ULONG",\n          value: 65536\n        }, {\n          name: "offsetToData",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "countSizePairs",\n          type: "USHORT",\n          value: 2\n        }, {\n          name: "axisCount",\n          type: "USHORT",\n          value: e.axes.length\n        }, {\n          name: "axisSize",\n          type: "USHORT",\n          value: 20\n        }, {\n          name: "instanceCount",\n          type: "USHORT",\n          value: e.instances.length\n        }, {\n          name: "instanceSize",\n          type: "USHORT",\n          value: 4 + 4 * e.axes.length\n        }]);\n        r.offsetToData = r.sizeOf();\n\n        for (var n = 0; n < e.axes.length; n++) {\n          r.fields = r.fields.concat(makeFvarAxis(n, e.axes[n], a));\n        }\n\n        for (var t = 0; t < e.instances.length; t++) {\n          r.fields = r.fields.concat(makeFvarInstance(t, e.instances[t], e.axes, a));\n        }\n\n        return r;\n      }\n\n      function parseFvarTable(e, a, r) {\n        var n = new parse.Parser(e, a),\n            t = n.parseULong();\n        check.argument(65536 === t, "Unsupported fvar table version.");\n        var s = n.parseOffset16();\n        n.skip("uShort", 1);\n\n        for (var u = n.parseUShort(), i = n.parseUShort(), p = n.parseUShort(), l = n.parseUShort(), v = [], o = 0; u > o; o++) {\n          v.push(parseFvarAxis(e, a + s + o * i, r));\n        }\n\n        for (var m = [], f = a + s + u * i, c = 0; p > c; c++) {\n          m.push(parseFvarInstance(e, f + c * l, v, r));\n        }\n\n        return {\n          axes: v,\n          instances: m\n        };\n      }\n\n      var check = require("../check"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.make = makeFvarTable, exports.parse = parseFvarTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13\n    }],\n    17: [function (require, module, exports) {\n      "use strict";\n\n      function parseGlyphCoordinate(e, r, t, o, a) {\n        var n;\n        return (r & o) > 0 ? (n = e.parseByte(), 0 === (r & a) && (n = -n), n = t + n) : n = (r & a) > 0 ? t : t + e.parseShort(), n;\n      }\n\n      function parseGlyph(e, r, t) {\n        var o = new parse.Parser(r, t);\n        e.numberOfContours = o.parseShort(), e._xMin = o.parseShort(), e._yMin = o.parseShort(), e._xMax = o.parseShort(), e._yMax = o.parseShort();\n        var a, n;\n\n        if (e.numberOfContours > 0) {\n          var s,\n              p = e.endPointIndices = [];\n\n          for (s = 0; s < e.numberOfContours; s += 1) {\n            p.push(o.parseUShort());\n          }\n\n          for (e.instructionLength = o.parseUShort(), e.instructions = [], s = 0; s < e.instructionLength; s += 1) {\n            e.instructions.push(o.parseByte());\n          }\n\n          var i = p[p.length - 1] + 1;\n\n          for (a = [], s = 0; i > s; s += 1) {\n            if (n = o.parseByte(), a.push(n), (8 & n) > 0) for (var h = o.parseByte(), l = 0; h > l; l += 1) {\n              a.push(n), s += 1;\n            }\n          }\n\n          if (check.argument(a.length === i, "Bad flags."), p.length > 0) {\n            var u,\n                c = [];\n\n            if (i > 0) {\n              for (s = 0; i > s; s += 1) {\n                n = a[s], u = {}, u.onCurve = !!(1 & n), u.lastPointOfContour = p.indexOf(s) >= 0, c.push(u);\n              }\n\n              var y = 0;\n\n              for (s = 0; i > s; s += 1) {\n                n = a[s], u = c[s], u.x = parseGlyphCoordinate(o, n, y, 2, 16), y = u.x;\n              }\n\n              var f = 0;\n\n              for (s = 0; i > s; s += 1) {\n                n = a[s], u = c[s], u.y = parseGlyphCoordinate(o, n, f, 4, 32), f = u.y;\n              }\n            }\n\n            e.points = c;\n          } else e.points = [];\n        } else if (0 === e.numberOfContours) e.points = [];else {\n          e.isComposite = !0, e.points = [], e.components = [];\n\n          for (var v = !0; v;) {\n            a = o.parseUShort();\n            var x = {\n              glyphIndex: o.parseUShort(),\n              xScale: 1,\n              scale01: 0,\n              scale10: 0,\n              yScale: 1,\n              dx: 0,\n              dy: 0\n            };\n            (1 & a) > 0 ? (2 & a) > 0 ? (x.dx = o.parseShort(), x.dy = o.parseShort()) : x.matchedPoints = [o.parseUShort(), o.parseUShort()] : (2 & a) > 0 ? (x.dx = o.parseChar(), x.dy = o.parseChar()) : x.matchedPoints = [o.parseByte(), o.parseByte()], (8 & a) > 0 ? x.xScale = x.yScale = o.parseF2Dot14() : (64 & a) > 0 ? (x.xScale = o.parseF2Dot14(), x.yScale = o.parseF2Dot14()) : (128 & a) > 0 && (x.xScale = o.parseF2Dot14(), x.scale01 = o.parseF2Dot14(), x.scale10 = o.parseF2Dot14(), x.yScale = o.parseF2Dot14()), e.components.push(x), v = !!(32 & a);\n          }\n        }\n      }\n\n      function transformPoints(e, r) {\n        for (var t = [], o = 0; o < e.length; o += 1) {\n          var a = e[o],\n              n = {\n            x: r.xScale * a.x + r.scale01 * a.y + r.dx,\n            y: r.scale10 * a.x + r.yScale * a.y + r.dy,\n            onCurve: a.onCurve,\n            lastPointOfContour: a.lastPointOfContour\n          };\n          t.push(n);\n        }\n\n        return t;\n      }\n\n      function getContours(e) {\n        for (var r = [], t = [], o = 0; o < e.length; o += 1) {\n          var a = e[o];\n          t.push(a), a.lastPointOfContour && (r.push(t), t = []);\n        }\n\n        return check.argument(0 === t.length, "There are still points left in the current contour."), r;\n      }\n\n      function getPath(e) {\n        var r = new path.Path();\n        if (!e) return r;\n\n        for (var t = getContours(e), o = 0; o < t.length; o += 1) {\n          var a,\n              n,\n              s = t[o],\n              p = s[0],\n              i = s[s.length - 1];\n          p.onCurve ? (a = null, n = !0) : (p = i.onCurve ? i : {\n            x: (p.x + i.x) / 2,\n            y: (p.y + i.y) / 2\n          }, a = p, n = !1), r.moveTo(p.x, p.y);\n\n          for (var h = n ? 1 : 0; h < s.length; h += 1) {\n            var l = s[h],\n                u = 0 === h ? p : s[h - 1];\n            if (u.onCurve && l.onCurve) r.lineTo(l.x, l.y);else if (u.onCurve && !l.onCurve) a = l;else if (u.onCurve || l.onCurve) {\n              if (u.onCurve || !l.onCurve) throw new Error("Invalid state.");\n              r.quadraticCurveTo(a.x, a.y, l.x, l.y), a = null;\n            } else {\n              var c = {\n                x: (u.x + l.x) / 2,\n                y: (u.y + l.y) / 2\n              };\n              r.quadraticCurveTo(u.x, u.y, c.x, c.y), a = l;\n            }\n          }\n\n          p !== i && (a ? r.quadraticCurveTo(a.x, a.y, p.x, p.y) : r.lineTo(p.x, p.y));\n        }\n\n        return r.closePath(), r;\n      }\n\n      function buildPath(e, r) {\n        if (r.isComposite) for (var t = 0; t < r.components.length; t += 1) {\n          var o = r.components[t],\n              a = e.get(o.glyphIndex);\n\n          if (a.getPath(), a.points) {\n            var n;\n            if (void 0 === o.matchedPoints) n = transformPoints(a.points, o);else {\n              if (o.matchedPoints[0] > r.points.length - 1 || o.matchedPoints[1] > a.points.length - 1) throw Error("Matched points out of range in " + r.name);\n              var s = r.points[o.matchedPoints[0]],\n                  p = a.points[o.matchedPoints[1]],\n                  i = {\n                xScale: o.xScale,\n                scale01: o.scale01,\n                scale10: o.scale10,\n                yScale: o.yScale,\n                dx: 0,\n                dy: 0\n              };\n              p = transformPoints([p], i)[0], i.dx = s.x - p.x, i.dy = s.y - p.y, n = transformPoints(a.points, i);\n            }\n            r.points = r.points.concat(n);\n          }\n        }\n        return getPath(r.points);\n      }\n\n      function parseGlyfTable(e, r, t, o) {\n        var a,\n            n = new glyphset.GlyphSet(o);\n\n        for (a = 0; a < t.length - 1; a += 1) {\n          var s = t[a],\n              p = t[a + 1];\n          s !== p ? n.push(a, glyphset.ttfGlyphLoader(o, a, parseGlyph, e, r + s, buildPath)) : n.push(a, glyphset.glyphLoader(o, a));\n        }\n\n        return n;\n      }\n\n      var check = require("../check"),\n          glyphset = require("../glyphset"),\n          parse = require("../parse"),\n          path = require("../path");\n\n      exports.parse = parseGlyfTable;\n    }, {\n      "../check": 2,\n      "../glyphset": 7,\n      "../parse": 10,\n      "../path": 11\n    }],\n    18: [function (require, module, exports) {\n      "use strict";\n\n      function parseTaggedListTable(r, e) {\n        for (var a = new parse.Parser(r, e), s = a.parseUShort(), t = [], o = 0; s > o; o++) {\n          t[a.parseTag()] = {\n            offset: a.parseUShort()\n          };\n        }\n\n        return t;\n      }\n\n      function parseCoverageTable(r, e) {\n        var a = new parse.Parser(r, e),\n            s = a.parseUShort(),\n            t = a.parseUShort();\n        if (1 === s) return a.parseUShortList(t);\n\n        if (2 === s) {\n          for (var o = []; t--;) {\n            for (var p = a.parseUShort(), n = a.parseUShort(), f = a.parseUShort(), i = p; n >= i; i++) {\n              o[f++] = i;\n            }\n          }\n\n          return o;\n        }\n      }\n\n      function parseClassDefTable(r, e) {\n        var a = new parse.Parser(r, e),\n            s = a.parseUShort();\n\n        if (1 === s) {\n          var t = a.parseUShort(),\n              o = a.parseUShort(),\n              p = a.parseUShortList(o);\n          return function (r) {\n            return p[r - t] || 0;\n          };\n        }\n\n        if (2 === s) {\n          for (var n = a.parseUShort(), f = [], i = [], h = [], S = 0; n > S; S++) {\n            f[S] = a.parseUShort(), i[S] = a.parseUShort(), h[S] = a.parseUShort();\n          }\n\n          return function (r) {\n            for (var e = 0, a = f.length - 1; a > e;) {\n              var s = e + a + 1 >> 1;\n              r < f[s] ? a = s - 1 : e = s;\n            }\n\n            return f[e] <= r && r <= i[e] ? h[e] || 0 : 0;\n          };\n        }\n      }\n\n      function parsePairPosSubTable(r, e) {\n        var a,\n            s,\n            t = new parse.Parser(r, e),\n            o = t.parseUShort(),\n            p = t.parseUShort(),\n            n = parseCoverageTable(r, e + p),\n            f = t.parseUShort(),\n            i = t.parseUShort();\n\n        if (4 === f && 0 === i) {\n          var h = {};\n\n          if (1 === o) {\n            for (var S = t.parseUShort(), u = [], v = t.parseOffset16List(S), U = 0; S > U; U++) {\n              var l = v[U],\n                  g = h[l];\n\n              if (!g) {\n                g = {}, t.relativeOffset = l;\n\n                for (var T = t.parseUShort(); T--;) {\n                  var c = t.parseUShort();\n                  f && (a = t.parseShort()), i && (s = t.parseShort()), g[c] = a;\n                }\n              }\n\n              u[n[U]] = g;\n            }\n\n            return function (r, e) {\n              var a = u[r];\n              return a ? a[e] : void 0;\n            };\n          }\n\n          if (2 === o) {\n            for (var b = t.parseUShort(), P = t.parseUShort(), L = t.parseUShort(), k = t.parseUShort(), d = parseClassDefTable(r, e + b), w = parseClassDefTable(r, e + P), O = [], C = 0; L > C; C++) {\n              for (var G = O[C] = [], K = 0; k > K; K++) {\n                f && (a = t.parseShort()), i && (s = t.parseShort()), G[K] = a;\n              }\n            }\n\n            var V = {};\n\n            for (C = 0; C < n.length; C++) {\n              V[n[C]] = 1;\n            }\n\n            return function (r, e) {\n              if (V[r]) {\n                var a = d(r),\n                    s = w(e),\n                    t = O[a];\n                return t ? t[s] : void 0;\n              }\n            };\n          }\n        }\n      }\n\n      function parseLookupTable(r, e) {\n        var a = new parse.Parser(r, e),\n            s = a.parseUShort(),\n            t = a.parseUShort(),\n            o = 16 & t,\n            p = a.parseUShort(),\n            n = a.parseOffset16List(p),\n            f = {\n          lookupType: s,\n          lookupFlag: t,\n          markFilteringSet: o ? a.parseUShort() : -1\n        };\n\n        if (2 === s) {\n          for (var i = [], h = 0; p > h; h++) {\n            i.push(parsePairPosSubTable(r, e + n[h]));\n          }\n\n          f.getKerningValue = function (r, e) {\n            for (var a = i.length; a--;) {\n              var s = i[a](r, e);\n              if (void 0 !== s) return s;\n            }\n\n            return 0;\n          };\n        }\n\n        return f;\n      }\n\n      function parseGposTable(r, e, a) {\n        var s = new parse.Parser(r, e),\n            t = s.parseFixed();\n        check.argument(1 === t, "Unsupported GPOS table version."), parseTaggedListTable(r, e + s.parseUShort()), parseTaggedListTable(r, e + s.parseUShort());\n        var o = s.parseUShort();\n        s.relativeOffset = o;\n\n        for (var p = s.parseUShort(), n = s.parseOffset16List(p), f = e + o, i = 0; p > i; i++) {\n          var h = parseLookupTable(r, f + n[i]);\n          2 !== h.lookupType || a.getGposKerningValue || (a.getGposKerningValue = h.getKerningValue);\n        }\n      }\n\n      var check = require("../check"),\n          parse = require("../parse");\n\n      exports.parse = parseGposTable;\n    }, {\n      "../check": 2,\n      "../parse": 10\n    }],\n    19: [function (require, module, exports) {\n      "use strict";\n\n      function parseGsubTable(e, t) {\n        t = t || 0;\n        var s = new Parser(e, t),\n            r = s.parseVersion();\n        return check.argument(1 === r, "Unsupported GSUB table version."), {\n          version: r,\n          scripts: s.parseScriptList(),\n          features: s.parseFeatureList(),\n          lookups: s.parseLookupList(subtableParsers)\n        };\n      }\n\n      function makeGsubTable(e) {\n        return new table.Table("GSUB", [{\n          name: "version",\n          type: "ULONG",\n          value: 65536\n        }, {\n          name: "scripts",\n          type: "TABLE",\n          value: new table.ScriptList(e.scripts)\n        }, {\n          name: "features",\n          type: "TABLE",\n          value: new table.FeatureList(e.features)\n        }, {\n          name: "lookups",\n          type: "TABLE",\n          value: new table.LookupList(e.lookups, subtableMakers)\n        }]);\n      }\n\n      var check = require("../check"),\n          Parser = require("../parse").Parser,\n          subtableParsers = new Array(9),\n          table = require("../table");\n\n      subtableParsers[1] = function () {\n        var e = this.offset + this.relativeOffset,\n            t = this.parseUShort();\n        return 1 === t ? {\n          substFormat: 1,\n          coverage: this.parsePointer(Parser.coverage),\n          deltaGlyphId: this.parseUShort()\n        } : 2 === t ? {\n          substFormat: 2,\n          coverage: this.parsePointer(Parser.coverage),\n          substitute: this.parseOffset16List()\n        } : void check.assert(!1, "0x" + e.toString(16) + ": lookup type 1 format must be 1 or 2.");\n      }, subtableParsers[2] = function () {\n        var e = this.parseUShort();\n        return check.argument(1 === e, "GSUB Multiple Substitution Subtable identifier-format must be 1"), {\n          substFormat: e,\n          coverage: this.parsePointer(Parser.coverage),\n          sequences: this.parseListOfLists()\n        };\n      }, subtableParsers[3] = function () {\n        var e = this.parseUShort();\n        return check.argument(1 === e, "GSUB Alternate Substitution Subtable identifier-format must be 1"), {\n          substFormat: e,\n          coverage: this.parsePointer(Parser.coverage),\n          alternateSets: this.parseListOfLists()\n        };\n      }, subtableParsers[4] = function () {\n        var e = this.parseUShort();\n        return check.argument(1 === e, "GSUB ligature table identifier-format must be 1"), {\n          substFormat: e,\n          coverage: this.parsePointer(Parser.coverage),\n          ligatureSets: this.parseListOfLists(function () {\n            return {\n              ligGlyph: this.parseUShort(),\n              components: this.parseUShortList(this.parseUShort() - 1)\n            };\n          })\n        };\n      };\n      var lookupRecordDesc = {\n        sequenceIndex: Parser.uShort,\n        lookupListIndex: Parser.uShort\n      };\n      subtableParsers[5] = function () {\n        var e = this.offset + this.relativeOffset,\n            t = this.parseUShort();\n        if (1 === t) return {\n          substFormat: t,\n          coverage: this.parsePointer(Parser.coverage),\n          ruleSets: this.parseListOfLists(function () {\n            var e = this.parseUShort(),\n                t = this.parseUShort();\n            return {\n              input: this.parseUShortList(e - 1),\n              lookupRecords: this.parseRecordList(t, lookupRecordDesc)\n            };\n          })\n        };\n        if (2 === t) return {\n          substFormat: t,\n          coverage: this.parsePointer(Parser.coverage),\n          classDef: this.parsePointer(Parser.classDef),\n          classSets: this.parseListOfLists(function () {\n            var e = this.parseUShort(),\n                t = this.parseUShort();\n            return {\n              classes: this.parseUShortList(e - 1),\n              lookupRecords: this.parseRecordList(t, lookupRecordDesc)\n            };\n          })\n        };\n\n        if (3 === t) {\n          var s = this.parseUShort(),\n              r = this.parseUShort();\n          return {\n            substFormat: t,\n            coverages: this.parseList(s, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(r, lookupRecordDesc)\n          };\n        }\n\n        check.assert(!1, "0x" + e.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");\n      }, subtableParsers[6] = function () {\n        var e = this.offset + this.relativeOffset,\n            t = this.parseUShort();\n        return 1 === t ? {\n          substFormat: 1,\n          coverage: this.parsePointer(Parser.coverage),\n          chainRuleSets: this.parseListOfLists(function () {\n            return {\n              backtrack: this.parseUShortList(),\n              input: this.parseUShortList(this.parseShort() - 1),\n              lookahead: this.parseUShortList(),\n              lookupRecords: this.parseRecordList(lookupRecordDesc)\n            };\n          })\n        } : 2 === t ? {\n          substFormat: 2,\n          coverage: this.parsePointer(Parser.coverage),\n          backtrackClassDef: this.parsePointer(Parser.classDef),\n          inputClassDef: this.parsePointer(Parser.classDef),\n          lookaheadClassDef: this.parsePointer(Parser.classDef),\n          chainClassSet: this.parseListOfLists(function () {\n            return {\n              backtrack: this.parseUShortList(),\n              input: this.parseUShortList(this.parseShort() - 1),\n              lookahead: this.parseUShortList(),\n              lookupRecords: this.parseRecordList(lookupRecordDesc)\n            };\n          })\n        } : 3 === t ? {\n          substFormat: 3,\n          backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n          inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n          lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n          lookupRecords: this.parseRecordList(lookupRecordDesc)\n        } : void check.assert(!1, "0x" + e.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");\n      }, subtableParsers[7] = function () {\n        var e = this.parseUShort();\n        check.argument(1 === e, "GSUB Extension Substitution subtable identifier-format must be 1");\n        var t = this.parseUShort(),\n            s = new Parser(this.data, this.offset + this.parseULong());\n        return {\n          substFormat: 1,\n          lookupType: t,\n          extension: subtableParsers[t].call(s)\n        };\n      }, subtableParsers[8] = function () {\n        var e = this.parseUShort();\n        return check.argument(1 === e, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), {\n          substFormat: e,\n          coverage: this.parsePointer(Parser.coverage),\n          backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n          lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n          substitutes: this.parseUShortList()\n        };\n      };\n      var subtableMakers = new Array(9);\n      subtableMakers[1] = function (e) {\n        return 1 === e.substFormat ? new table.Table("substitutionTable", [{\n          name: "substFormat",\n          type: "USHORT",\n          value: 1\n        }, {\n          name: "coverage",\n          type: "TABLE",\n          value: new table.Coverage(e.coverage)\n        }, {\n          name: "deltaGlyphID",\n          type: "USHORT",\n          value: e.deltaGlyphId\n        }]) : new table.Table("substitutionTable", [{\n          name: "substFormat",\n          type: "USHORT",\n          value: 2\n        }, {\n          name: "coverage",\n          type: "TABLE",\n          value: new table.Coverage(e.coverage)\n        }].concat(table.ushortList("substitute", e.substitute)));\n      }, subtableMakers[3] = function (e) {\n        return check.assert(1 === e.substFormat, "Lookup type 3 substFormat must be 1."), new table.Table("substitutionTable", [{\n          name: "substFormat",\n          type: "USHORT",\n          value: 1\n        }, {\n          name: "coverage",\n          type: "TABLE",\n          value: new table.Coverage(e.coverage)\n        }].concat(table.tableList("altSet", e.alternateSets, function (e) {\n          return new table.Table("alternateSetTable", table.ushortList("alternate", e));\n        })));\n      }, subtableMakers[4] = function (e) {\n        return check.assert(1 === e.substFormat, "Lookup type 4 substFormat must be 1."), new table.Table("substitutionTable", [{\n          name: "substFormat",\n          type: "USHORT",\n          value: 1\n        }, {\n          name: "coverage",\n          type: "TABLE",\n          value: new table.Coverage(e.coverage)\n        }].concat(table.tableList("ligSet", e.ligatureSets, function (e) {\n          return new table.Table("ligatureSetTable", table.tableList("ligature", e, function (e) {\n            return new table.Table("ligatureTable", [{\n              name: "ligGlyph",\n              type: "USHORT",\n              value: e.ligGlyph\n            }].concat(table.ushortList("component", e.components, e.components.length + 1)));\n          }));\n        })));\n      }, exports.parse = parseGsubTable, exports.make = makeGsubTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13\n    }],\n    20: [function (require, module, exports) {\n      "use strict";\n\n      function parseHeadTable(e, a) {\n        var t = {},\n            r = new parse.Parser(e, a);\n        return t.version = r.parseVersion(), t.fontRevision = Math.round(1e3 * r.parseFixed()) / 1e3, t.checkSumAdjustment = r.parseULong(), t.magicNumber = r.parseULong(), check.argument(1594834165 === t.magicNumber, "Font header has wrong magic number."), t.flags = r.parseUShort(), t.unitsPerEm = r.parseUShort(), t.created = r.parseLongDateTime(), t.modified = r.parseLongDateTime(), t.xMin = r.parseShort(), t.yMin = r.parseShort(), t.xMax = r.parseShort(), t.yMax = r.parseShort(), t.macStyle = r.parseUShort(), t.lowestRecPPEM = r.parseUShort(), t.fontDirectionHint = r.parseShort(), t.indexToLocFormat = r.parseShort(), t.glyphDataFormat = r.parseShort(), t;\n      }\n\n      function makeHeadTable(e) {\n        var a = Math.round(new Date().getTime() / 1e3) + 2082844800,\n            t = a;\n        return e.createdTimestamp && (t = e.createdTimestamp + 2082844800), new table.Table("head", [{\n          name: "version",\n          type: "FIXED",\n          value: 65536\n        }, {\n          name: "fontRevision",\n          type: "FIXED",\n          value: 65536\n        }, {\n          name: "checkSumAdjustment",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "magicNumber",\n          type: "ULONG",\n          value: 1594834165\n        }, {\n          name: "flags",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "unitsPerEm",\n          type: "USHORT",\n          value: 1e3\n        }, {\n          name: "created",\n          type: "LONGDATETIME",\n          value: t\n        }, {\n          name: "modified",\n          type: "LONGDATETIME",\n          value: a\n        }, {\n          name: "xMin",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "yMin",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "xMax",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "yMax",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "macStyle",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "lowestRecPPEM",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "fontDirectionHint",\n          type: "SHORT",\n          value: 2\n        }, {\n          name: "indexToLocFormat",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "glyphDataFormat",\n          type: "SHORT",\n          value: 0\n        }], e);\n      }\n\n      var check = require("../check"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseHeadTable, exports.make = makeHeadTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13\n    }],\n    21: [function (require, module, exports) {\n      "use strict";\n\n      function parseHheaTable(e, a) {\n        var r = {},\n            t = new parse.Parser(e, a);\n        return r.version = t.parseVersion(), r.ascender = t.parseShort(), r.descender = t.parseShort(), r.lineGap = t.parseShort(), r.advanceWidthMax = t.parseUShort(), r.minLeftSideBearing = t.parseShort(), r.minRightSideBearing = t.parseShort(), r.xMaxExtent = t.parseShort(), r.caretSlopeRise = t.parseShort(), r.caretSlopeRun = t.parseShort(), r.caretOffset = t.parseShort(), t.relativeOffset += 8, r.metricDataFormat = t.parseShort(), r.numberOfHMetrics = t.parseUShort(), r;\n      }\n\n      function makeHheaTable(e) {\n        return new table.Table("hhea", [{\n          name: "version",\n          type: "FIXED",\n          value: 65536\n        }, {\n          name: "ascender",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "descender",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "lineGap",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "advanceWidthMax",\n          type: "UFWORD",\n          value: 0\n        }, {\n          name: "minLeftSideBearing",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "minRightSideBearing",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "xMaxExtent",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "caretSlopeRise",\n          type: "SHORT",\n          value: 1\n        }, {\n          name: "caretSlopeRun",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "caretOffset",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "reserved1",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "reserved2",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "reserved3",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "reserved4",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "metricDataFormat",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "numberOfHMetrics",\n          type: "USHORT",\n          value: 0\n        }], e);\n      }\n\n      var parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseHheaTable, exports.make = makeHheaTable;\n    }, {\n      "../parse": 10,\n      "../table": 13\n    }],\n    22: [function (require, module, exports) {\n      "use strict";\n\n      function parseHmtxTable(e, a, r, t, s) {\n        for (var i, l, n = new parse.Parser(e, a), p = 0; t > p; p += 1) {\n          r > p && (i = n.parseUShort(), l = n.parseShort());\n          var d = s.get(p);\n          d.advanceWidth = i, d.leftSideBearing = l;\n        }\n      }\n\n      function makeHmtxTable(e) {\n        for (var a = new table.Table("hmtx", []), r = 0; r < e.length; r += 1) {\n          var t = e.get(r),\n              s = t.advanceWidth || 0,\n              i = t.leftSideBearing || 0;\n          a.fields.push({\n            name: "advanceWidth_" + r,\n            type: "USHORT",\n            value: s\n          }), a.fields.push({\n            name: "leftSideBearing_" + r,\n            type: "SHORT",\n            value: i\n          });\n        }\n\n        return a;\n      }\n\n      var parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseHmtxTable, exports.make = makeHmtxTable;\n    }, {\n      "../parse": 10,\n      "../table": 13\n    }],\n    23: [function (require, module, exports) {\n      "use strict";\n\n      function parseKernTable(r, e) {\n        var a = {},\n            s = new parse.Parser(r, e),\n            p = s.parseUShort();\n        check.argument(0 === p, "Unsupported kern table version."), s.skip("uShort", 1);\n        var t = s.parseUShort();\n        check.argument(0 === t, "Unsupported kern sub-table version."), s.skip("uShort", 2);\n        var o = s.parseUShort();\n        s.skip("uShort", 3);\n\n        for (var n = 0; o > n; n += 1) {\n          var h = s.parseUShort(),\n              u = s.parseUShort(),\n              c = s.parseShort();\n          a[h + "," + u] = c;\n        }\n\n        return a;\n      }\n\n      var check = require("../check"),\n          parse = require("../parse");\n\n      exports.parse = parseKernTable;\n    }, {\n      "../check": 2,\n      "../parse": 10\n    }],\n    24: [function (require, module, exports) {\n      "use strict";\n\n      function parseLocaTable(r, a, e, s) {\n        for (var p = new parse.Parser(r, a), o = s ? p.parseUShort : p.parseULong, t = [], c = 0; e + 1 > c; c += 1) {\n          var n = o.call(p);\n          s && (n *= 2), t.push(n);\n        }\n\n        return t;\n      }\n\n      var parse = require("../parse");\n\n      exports.parse = parseLocaTable;\n    }, {\n      "../parse": 10\n    }],\n    25: [function (require, module, exports) {\n      "use strict";\n\n      function makeLtagTable(e) {\n        for (var a = new table.Table("ltag", [{\n          name: "version",\n          type: "ULONG",\n          value: 1\n        }, {\n          name: "flags",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "numTags",\n          type: "ULONG",\n          value: e.length\n        }]), r = "", t = 12 + 4 * e.length, n = 0; n < e.length; ++n) {\n          var s = r.indexOf(e[n]);\n          0 > s && (s = r.length, r += e[n]), a.fields.push({\n            name: "offset " + n,\n            type: "USHORT",\n            value: t + s\n          }), a.fields.push({\n            name: "length " + n,\n            type: "USHORT",\n            value: e[n].length\n          });\n        }\n\n        return a.fields.push({\n          name: "stringPool",\n          type: "CHARARRAY",\n          value: r\n        }), a;\n      }\n\n      function parseLtagTable(e, a) {\n        var r = new parse.Parser(e, a),\n            t = r.parseULong();\n        check.argument(1 === t, "Unsupported ltag table version."), r.skip("uLong", 1);\n\n        for (var n = r.parseULong(), s = [], l = 0; n > l; l++) {\n          for (var p = "", u = a + r.parseUShort(), g = r.parseUShort(), o = u; u + g > o; ++o) {\n            p += String.fromCharCode(e.getInt8(o));\n          }\n\n          s.push(p);\n        }\n\n        return s;\n      }\n\n      var check = require("../check"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.make = makeLtagTable, exports.parse = parseLtagTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13\n    }],\n    26: [function (require, module, exports) {\n      "use strict";\n\n      function parseMaxpTable(e, a) {\n        var r = {},\n            s = new parse.Parser(e, a);\n        return r.version = s.parseVersion(), r.numGlyphs = s.parseUShort(), 1 === r.version && (r.maxPoints = s.parseUShort(), r.maxContours = s.parseUShort(), r.maxCompositePoints = s.parseUShort(), r.maxCompositeContours = s.parseUShort(), r.maxZones = s.parseUShort(), r.maxTwilightPoints = s.parseUShort(), r.maxStorage = s.parseUShort(), r.maxFunctionDefs = s.parseUShort(), r.maxInstructionDefs = s.parseUShort(), r.maxStackElements = s.parseUShort(), r.maxSizeOfInstructions = s.parseUShort(), r.maxComponentElements = s.parseUShort(), r.maxComponentDepth = s.parseUShort()), r;\n      }\n\n      function makeMaxpTable(e) {\n        return new table.Table("maxp", [{\n          name: "version",\n          type: "FIXED",\n          value: 20480\n        }, {\n          name: "numGlyphs",\n          type: "USHORT",\n          value: e\n        }]);\n      }\n\n      var parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseMaxpTable, exports.make = makeMaxpTable;\n    }, {\n      "../parse": 10,\n      "../table": 13\n    }],\n    27: [function (require, module, exports) {\n      "use strict";\n\n      function parseMetaTable(e, a) {\n        var r = new parse.Parser(e, a),\n            t = r.parseULong();\n        check.argument(1 === t, "Unsupported META table version."), r.parseULong(), r.parseULong();\n\n        for (var s = r.parseULong(), n = {}, p = 0; s > p; p++) {\n          var l = r.parseTag(),\n              u = r.parseULong(),\n              o = r.parseULong(),\n              v = decode.UTF8(e, a + u, o);\n          n[l] = v;\n        }\n\n        return n;\n      }\n\n      function makeMetaTable(e) {\n        var a = Object.keys(e).length,\n            r = "",\n            t = 16 + 12 * a,\n            s = new table.Table("meta", [{\n          name: "version",\n          type: "ULONG",\n          value: 1\n        }, {\n          name: "flags",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "offset",\n          type: "ULONG",\n          value: t\n        }, {\n          name: "numTags",\n          type: "ULONG",\n          value: a\n        }]);\n\n        for (var n in e) {\n          var p = r.length;\n          r += e[n], s.fields.push({\n            name: "tag " + n,\n            type: "TAG",\n            value: n\n          }), s.fields.push({\n            name: "offset " + n,\n            type: "ULONG",\n            value: t + p\n          }), s.fields.push({\n            name: "length " + n,\n            type: "ULONG",\n            value: e[n].length\n          });\n        }\n\n        return s.fields.push({\n          name: "stringPool",\n          type: "CHARARRAY",\n          value: r\n        }), s;\n      }\n\n      var types = require("../types"),\n          decode = types.decode,\n          check = require("../check"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parseMetaTable, exports.make = makeMetaTable;\n    }, {\n      "../check": 2,\n      "../parse": 10,\n      "../table": 13,\n      "../types": 32\n    }],\n    28: [function (require, module, exports) {\n      "use strict";\n\n      function getLanguageCode(e, a, r) {\n        switch (e) {\n          case 0:\n            if (65535 === a) return "und";\n            if (r) return r[a];\n            break;\n\n          case 1:\n            return macLanguages[a];\n\n          case 3:\n            return windowsLanguages[a];\n        }\n\n        return void 0;\n      }\n\n      function getEncoding(e, a, r) {\n        switch (e) {\n          case 0:\n            return utf16;\n\n          case 1:\n            return macLanguageEncodings[r] || macScriptEncodings[a];\n\n          case 3:\n            if (1 === a || 10 === a) return utf16;\n        }\n\n        return void 0;\n      }\n\n      function parseNameTable(e, a, r) {\n        for (var n = {}, t = new parse.Parser(e, a), s = t.parseUShort(), m = t.parseUShort(), i = t.offset + t.parseUShort(), c = 0; m > c; c++) {\n          var o = t.parseUShort(),\n              u = t.parseUShort(),\n              l = t.parseUShort(),\n              g = t.parseUShort(),\n              d = nameTableNames[g] || g,\n              f = t.parseUShort(),\n              p = t.parseUShort(),\n              h = getLanguageCode(o, l, r),\n              v = getEncoding(o, u, l);\n\n          if (void 0 !== v && void 0 !== h) {\n            var x;\n\n            if (x = v === utf16 ? decode.UTF16(e, i + p, f) : decode.MACSTRING(e, i + p, f, v)) {\n              var y = n[d];\n              void 0 === y && (y = n[d] = {}), y[h] = x;\n            }\n          }\n        }\n\n        var b = 0;\n        return 1 === s && (b = t.parseUShort()), n;\n      }\n\n      function reverseDict(e) {\n        var a = {};\n\n        for (var r in e) {\n          a[e[r]] = parseInt(r);\n        }\n\n        return a;\n      }\n\n      function makeNameRecord(e, a, r, n, t, s) {\n        return new table.Record("NameRecord", [{\n          name: "platformID",\n          type: "USHORT",\n          value: e\n        }, {\n          name: "encodingID",\n          type: "USHORT",\n          value: a\n        }, {\n          name: "languageID",\n          type: "USHORT",\n          value: r\n        }, {\n          name: "nameID",\n          type: "USHORT",\n          value: n\n        }, {\n          name: "length",\n          type: "USHORT",\n          value: t\n        }, {\n          name: "offset",\n          type: "USHORT",\n          value: s\n        }]);\n      }\n\n      function findSubArray(e, a) {\n        var r = e.length,\n            n = a.length - r + 1;\n\n        e: for (var t = 0; n > t; t++) {\n          for (; n > t; t++) {\n            for (var s = 0; r > s; s++) {\n              if (a[t + s] !== e[s]) continue e;\n            }\n\n            return t;\n          }\n        }\n\n        return -1;\n      }\n\n      function addStringToPool(e, a) {\n        var r = findSubArray(e, a);\n\n        if (0 > r) {\n          r = a.length;\n\n          for (var n = 0, t = e.length; t > n; ++n) {\n            a.push(e[n]);\n          }\n        }\n\n        return r;\n      }\n\n      function makeNameTable(e, a) {\n        var r,\n            n = [],\n            t = {},\n            s = reverseDict(nameTableNames);\n\n        for (var m in e) {\n          var i = s[m];\n          if (void 0 === i && (i = m), r = parseInt(i), isNaN(r)) throw new Error(\'Name table entry "\' + m + \'" does not exist, see nameTableNames for complete list.\');\n          t[r] = e[m], n.push(r);\n        }\n\n        for (var c = reverseDict(macLanguages), o = reverseDict(windowsLanguages), u = [], l = [], g = 0; g < n.length; g++) {\n          r = n[g];\n          var d = t[r];\n\n          for (var f in d) {\n            var p = d[f],\n                h = 1,\n                v = c[f],\n                x = macLanguageToScript[v],\n                y = getEncoding(h, x, v),\n                b = encode.MACSTRING(p, y);\n            void 0 === b && (h = 0, v = a.indexOf(f), 0 > v && (v = a.length, a.push(f)), x = 4, b = encode.UTF16(p));\n            var k = addStringToPool(b, l);\n            u.push(makeNameRecord(h, x, v, r, b.length, k));\n            var S = o[f];\n\n            if (void 0 !== S) {\n              var T = encode.UTF16(p),\n                  N = addStringToPool(T, l);\n              u.push(makeNameRecord(3, 1, S, r, T.length, N));\n            }\n          }\n        }\n\n        u.sort(function (e, a) {\n          return e.platformID - a.platformID || e.encodingID - a.encodingID || e.languageID - a.languageID || e.nameID - a.nameID;\n        });\n\n        for (var U = new table.Table("name", [{\n          name: "format",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "count",\n          type: "USHORT",\n          value: u.length\n        }, {\n          name: "stringOffset",\n          type: "USHORT",\n          value: 6 + 12 * u.length\n        }]), I = 0; I < u.length; I++) {\n          U.fields.push({\n            name: "record_" + I,\n            type: "RECORD",\n            value: u[I]\n          });\n        }\n\n        return U.fields.push({\n          name: "strings",\n          type: "LITERAL",\n          value: l\n        }), U;\n      }\n\n      var types = require("../types"),\n          decode = types.decode,\n          encode = types.encode,\n          parse = require("../parse"),\n          table = require("../table"),\n          nameTableNames = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"],\n          macLanguages = {\n        0: "en",\n        1: "fr",\n        2: "de",\n        3: "it",\n        4: "nl",\n        5: "sv",\n        6: "es",\n        7: "da",\n        8: "pt",\n        9: "no",\n        10: "he",\n        11: "ja",\n        12: "ar",\n        13: "fi",\n        14: "el",\n        15: "is",\n        16: "mt",\n        17: "tr",\n        18: "hr",\n        19: "zh-Hant",\n        20: "ur",\n        21: "hi",\n        22: "th",\n        23: "ko",\n        24: "lt",\n        25: "pl",\n        26: "hu",\n        27: "es",\n        28: "lv",\n        29: "se",\n        30: "fo",\n        31: "fa",\n        32: "ru",\n        33: "zh",\n        34: "nl-BE",\n        35: "ga",\n        36: "sq",\n        37: "ro",\n        38: "cz",\n        39: "sk",\n        40: "si",\n        41: "yi",\n        42: "sr",\n        43: "mk",\n        44: "bg",\n        45: "uk",\n        46: "be",\n        47: "uz",\n        48: "kk",\n        49: "az-Cyrl",\n        50: "az-Arab",\n        51: "hy",\n        52: "ka",\n        53: "mo",\n        54: "ky",\n        55: "tg",\n        56: "tk",\n        57: "mn-CN",\n        58: "mn",\n        59: "ps",\n        60: "ks",\n        61: "ku",\n        62: "sd",\n        63: "bo",\n        64: "ne",\n        65: "sa",\n        66: "mr",\n        67: "bn",\n        68: "as",\n        69: "gu",\n        70: "pa",\n        71: "or",\n        72: "ml",\n        73: "kn",\n        74: "ta",\n        75: "te",\n        76: "si",\n        77: "my",\n        78: "km",\n        79: "lo",\n        80: "vi",\n        81: "id",\n        82: "tl",\n        83: "ms",\n        84: "ms-Arab",\n        85: "am",\n        86: "ti",\n        87: "om",\n        88: "so",\n        89: "sw",\n        90: "rw",\n        91: "rn",\n        92: "ny",\n        93: "mg",\n        94: "eo",\n        128: "cy",\n        129: "eu",\n        130: "ca",\n        131: "la",\n        132: "qu",\n        133: "gn",\n        134: "ay",\n        135: "tt",\n        136: "ug",\n        137: "dz",\n        138: "jv",\n        139: "su",\n        140: "gl",\n        141: "af",\n        142: "br",\n        143: "iu",\n        144: "gd",\n        145: "gv",\n        146: "ga",\n        147: "to",\n        148: "el-polyton",\n        149: "kl",\n        150: "az",\n        151: "nn"\n      },\n          macLanguageToScript = {\n        0: 0,\n        1: 0,\n        2: 0,\n        3: 0,\n        4: 0,\n        5: 0,\n        6: 0,\n        7: 0,\n        8: 0,\n        9: 0,\n        10: 5,\n        11: 1,\n        12: 4,\n        13: 0,\n        14: 6,\n        15: 0,\n        16: 0,\n        17: 0,\n        18: 0,\n        19: 2,\n        20: 4,\n        21: 9,\n        22: 21,\n        23: 3,\n        24: 29,\n        25: 29,\n        26: 29,\n        27: 29,\n        28: 29,\n        29: 0,\n        30: 0,\n        31: 4,\n        32: 7,\n        33: 25,\n        34: 0,\n        35: 0,\n        36: 0,\n        37: 0,\n        38: 29,\n        39: 29,\n        40: 0,\n        41: 5,\n        42: 7,\n        43: 7,\n        44: 7,\n        45: 7,\n        46: 7,\n        47: 7,\n        48: 7,\n        49: 7,\n        50: 4,\n        51: 24,\n        52: 23,\n        53: 7,\n        54: 7,\n        55: 7,\n        56: 7,\n        57: 27,\n        58: 7,\n        59: 4,\n        60: 4,\n        61: 4,\n        62: 4,\n        63: 26,\n        64: 9,\n        65: 9,\n        66: 9,\n        67: 13,\n        68: 13,\n        69: 11,\n        70: 10,\n        71: 12,\n        72: 17,\n        73: 16,\n        74: 14,\n        75: 15,\n        76: 18,\n        77: 19,\n        78: 20,\n        79: 22,\n        80: 30,\n        81: 0,\n        82: 0,\n        83: 0,\n        84: 4,\n        85: 28,\n        86: 28,\n        87: 28,\n        88: 0,\n        89: 0,\n        90: 0,\n        91: 0,\n        92: 0,\n        93: 0,\n        94: 0,\n        128: 0,\n        129: 0,\n        130: 0,\n        131: 0,\n        132: 0,\n        133: 0,\n        134: 0,\n        135: 7,\n        136: 4,\n        137: 26,\n        138: 0,\n        139: 0,\n        140: 0,\n        141: 0,\n        142: 0,\n        143: 28,\n        144: 0,\n        145: 0,\n        146: 0,\n        147: 0,\n        148: 6,\n        149: 0,\n        150: 0,\n        151: 0\n      },\n          windowsLanguages = {\n        1078: "af",\n        1052: "sq",\n        1156: "gsw",\n        1118: "am",\n        5121: "ar-DZ",\n        15361: "ar-BH",\n        3073: "ar",\n        2049: "ar-IQ",\n        11265: "ar-JO",\n        13313: "ar-KW",\n        12289: "ar-LB",\n        4097: "ar-LY",\n        6145: "ary",\n        8193: "ar-OM",\n        16385: "ar-QA",\n        1025: "ar-SA",\n        10241: "ar-SY",\n        7169: "aeb",\n        14337: "ar-AE",\n        9217: "ar-YE",\n        1067: "hy",\n        1101: "as",\n        2092: "az-Cyrl",\n        1068: "az",\n        1133: "ba",\n        1069: "eu",\n        1059: "be",\n        2117: "bn",\n        1093: "bn-IN",\n        8218: "bs-Cyrl",\n        5146: "bs",\n        1150: "br",\n        1026: "bg",\n        1027: "ca",\n        3076: "zh-HK",\n        5124: "zh-MO",\n        2052: "zh",\n        4100: "zh-SG",\n        1028: "zh-TW",\n        1155: "co",\n        1050: "hr",\n        4122: "hr-BA",\n        1029: "cs",\n        1030: "da",\n        1164: "prs",\n        1125: "dv",\n        2067: "nl-BE",\n        1043: "nl",\n        3081: "en-AU",\n        10249: "en-BZ",\n        4105: "en-CA",\n        9225: "en-029",\n        16393: "en-IN",\n        6153: "en-IE",\n        8201: "en-JM",\n        17417: "en-MY",\n        5129: "en-NZ",\n        13321: "en-PH",\n        18441: "en-SG",\n        7177: "en-ZA",\n        11273: "en-TT",\n        2057: "en-GB",\n        1033: "en",\n        12297: "en-ZW",\n        1061: "et",\n        1080: "fo",\n        1124: "fil",\n        1035: "fi",\n        2060: "fr-BE",\n        3084: "fr-CA",\n        1036: "fr",\n        5132: "fr-LU",\n        6156: "fr-MC",\n        4108: "fr-CH",\n        1122: "fy",\n        1110: "gl",\n        1079: "ka",\n        3079: "de-AT",\n        1031: "de",\n        5127: "de-LI",\n        4103: "de-LU",\n        2055: "de-CH",\n        1032: "el",\n        1135: "kl",\n        1095: "gu",\n        1128: "ha",\n        1037: "he",\n        1081: "hi",\n        1038: "hu",\n        1039: "is",\n        1136: "ig",\n        1057: "id",\n        1117: "iu",\n        2141: "iu-Latn",\n        2108: "ga",\n        1076: "xh",\n        1077: "zu",\n        1040: "it",\n        2064: "it-CH",\n        1041: "ja",\n        1099: "kn",\n        1087: "kk",\n        1107: "km",\n        1158: "quc",\n        1159: "rw",\n        1089: "sw",\n        1111: "kok",\n        1042: "ko",\n        1088: "ky",\n        1108: "lo",\n        1062: "lv",\n        1063: "lt",\n        2094: "dsb",\n        1134: "lb",\n        1071: "mk",\n        2110: "ms-BN",\n        1086: "ms",\n        1100: "ml",\n        1082: "mt",\n        1153: "mi",\n        1146: "arn",\n        1102: "mr",\n        1148: "moh",\n        1104: "mn",\n        2128: "mn-CN",\n        1121: "ne",\n        1044: "nb",\n        2068: "nn",\n        1154: "oc",\n        1096: "or",\n        1123: "ps",\n        1045: "pl",\n        1046: "pt",\n        2070: "pt-PT",\n        1094: "pa",\n        1131: "qu-BO",\n        2155: "qu-EC",\n        3179: "qu",\n        1048: "ro",\n        1047: "rm",\n        1049: "ru",\n        9275: "smn",\n        4155: "smj-NO",\n        5179: "smj",\n        3131: "se-FI",\n        1083: "se",\n        2107: "se-SE",\n        8251: "sms",\n        6203: "sma-NO",\n        7227: "sms",\n        1103: "sa",\n        7194: "sr-Cyrl-BA",\n        3098: "sr",\n        6170: "sr-Latn-BA",\n        2074: "sr-Latn",\n        1132: "nso",\n        1074: "tn",\n        1115: "si",\n        1051: "sk",\n        1060: "sl",\n        11274: "es-AR",\n        16394: "es-BO",\n        13322: "es-CL",\n        9226: "es-CO",\n        5130: "es-CR",\n        7178: "es-DO",\n        12298: "es-EC",\n        17418: "es-SV",\n        4106: "es-GT",\n        18442: "es-HN",\n        2058: "es-MX",\n        19466: "es-NI",\n        6154: "es-PA",\n        15370: "es-PY",\n        10250: "es-PE",\n        20490: "es-PR",\n        3082: "es",\n        1034: "es",\n        21514: "es-US",\n        14346: "es-UY",\n        8202: "es-VE",\n        2077: "sv-FI",\n        1053: "sv",\n        1114: "syr",\n        1064: "tg",\n        2143: "tzm",\n        1097: "ta",\n        1092: "tt",\n        1098: "te",\n        1054: "th",\n        1105: "bo",\n        1055: "tr",\n        1090: "tk",\n        1152: "ug",\n        1058: "uk",\n        1070: "hsb",\n        1056: "ur",\n        2115: "uz-Cyrl",\n        1091: "uz",\n        1066: "vi",\n        1106: "cy",\n        1160: "wo",\n        1157: "sah",\n        1144: "ii",\n        1130: "yo"\n      },\n          utf16 = "utf-16",\n          macScriptEncodings = {\n        0: "macintosh",\n        1: "x-mac-japanese",\n        2: "x-mac-chinesetrad",\n        3: "x-mac-korean",\n        6: "x-mac-greek",\n        7: "x-mac-cyrillic",\n        9: "x-mac-devanagai",\n        10: "x-mac-gurmukhi",\n        11: "x-mac-gujarati",\n        12: "x-mac-oriya",\n        13: "x-mac-bengali",\n        14: "x-mac-tamil",\n        15: "x-mac-telugu",\n        16: "x-mac-kannada",\n        17: "x-mac-malayalam",\n        18: "x-mac-sinhalese",\n        19: "x-mac-burmese",\n        20: "x-mac-khmer",\n        21: "x-mac-thai",\n        22: "x-mac-lao",\n        23: "x-mac-georgian",\n        24: "x-mac-armenian",\n        25: "x-mac-chinesesimp",\n        26: "x-mac-tibetan",\n        27: "x-mac-mongolian",\n        28: "x-mac-ethiopic",\n        29: "x-mac-ce",\n        30: "x-mac-vietnamese",\n        31: "x-mac-extarabic"\n      },\n          macLanguageEncodings = {\n        15: "x-mac-icelandic",\n        17: "x-mac-turkish",\n        18: "x-mac-croatian",\n        24: "x-mac-ce",\n        25: "x-mac-ce",\n        26: "x-mac-ce",\n        27: "x-mac-ce",\n        28: "x-mac-ce",\n        30: "x-mac-icelandic",\n        37: "x-mac-romanian",\n        38: "x-mac-ce",\n        39: "x-mac-ce",\n        40: "x-mac-ce",\n        143: "x-mac-inuit",\n        146: "x-mac-gaelic"\n      };\n\n      exports.parse = parseNameTable, exports.make = makeNameTable;\n    }, {\n      "../parse": 10,\n      "../table": 13,\n      "../types": 32\n    }],\n    29: [function (require, module, exports) {\n      "use strict";\n\n      function getUnicodeRange(e) {\n        for (var n = 0; n < unicodeRanges.length; n += 1) {\n          var a = unicodeRanges[n];\n          if (e >= a.begin && e < a.end) return n;\n        }\n\n        return -1;\n      }\n\n      function parseOS2Table(e, n) {\n        var a = {},\n            i = new parse.Parser(e, n);\n        a.version = i.parseUShort(), a.xAvgCharWidth = i.parseShort(), a.usWeightClass = i.parseUShort(), a.usWidthClass = i.parseUShort(), a.fsType = i.parseUShort(), a.ySubscriptXSize = i.parseShort(), a.ySubscriptYSize = i.parseShort(), a.ySubscriptXOffset = i.parseShort(), a.ySubscriptYOffset = i.parseShort(), a.ySuperscriptXSize = i.parseShort(), a.ySuperscriptYSize = i.parseShort(), a.ySuperscriptXOffset = i.parseShort(), a.ySuperscriptYOffset = i.parseShort(), a.yStrikeoutSize = i.parseShort(), a.yStrikeoutPosition = i.parseShort(), a.sFamilyClass = i.parseShort(), a.panose = [];\n\n        for (var t = 0; 10 > t; t++) {\n          a.panose[t] = i.parseByte();\n        }\n\n        return a.ulUnicodeRange1 = i.parseULong(), a.ulUnicodeRange2 = i.parseULong(), a.ulUnicodeRange3 = i.parseULong(), a.ulUnicodeRange4 = i.parseULong(), a.achVendID = String.fromCharCode(i.parseByte(), i.parseByte(), i.parseByte(), i.parseByte()), a.fsSelection = i.parseUShort(), a.usFirstCharIndex = i.parseUShort(), a.usLastCharIndex = i.parseUShort(), a.sTypoAscender = i.parseShort(), a.sTypoDescender = i.parseShort(), a.sTypoLineGap = i.parseShort(), a.usWinAscent = i.parseUShort(), a.usWinDescent = i.parseUShort(), a.version >= 1 && (a.ulCodePageRange1 = i.parseULong(), a.ulCodePageRange2 = i.parseULong()), a.version >= 2 && (a.sxHeight = i.parseShort(), a.sCapHeight = i.parseShort(), a.usDefaultChar = i.parseUShort(), a.usBreakChar = i.parseUShort(), a.usMaxContent = i.parseUShort()), a;\n      }\n\n      function makeOS2Table(e) {\n        return new table.Table("OS/2", [{\n          name: "version",\n          type: "USHORT",\n          value: 3\n        }, {\n          name: "xAvgCharWidth",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "usWeightClass",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usWidthClass",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "fsType",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "ySubscriptXSize",\n          type: "SHORT",\n          value: 650\n        }, {\n          name: "ySubscriptYSize",\n          type: "SHORT",\n          value: 699\n        }, {\n          name: "ySubscriptXOffset",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "ySubscriptYOffset",\n          type: "SHORT",\n          value: 140\n        }, {\n          name: "ySuperscriptXSize",\n          type: "SHORT",\n          value: 650\n        }, {\n          name: "ySuperscriptYSize",\n          type: "SHORT",\n          value: 699\n        }, {\n          name: "ySuperscriptXOffset",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "ySuperscriptYOffset",\n          type: "SHORT",\n          value: 479\n        }, {\n          name: "yStrikeoutSize",\n          type: "SHORT",\n          value: 49\n        }, {\n          name: "yStrikeoutPosition",\n          type: "SHORT",\n          value: 258\n        }, {\n          name: "sFamilyClass",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "bFamilyType",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bSerifStyle",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bWeight",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bProportion",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bContrast",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bStrokeVariation",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bArmStyle",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bLetterform",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bMidline",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "bXHeight",\n          type: "BYTE",\n          value: 0\n        }, {\n          name: "ulUnicodeRange1",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "ulUnicodeRange2",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "ulUnicodeRange3",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "ulUnicodeRange4",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "achVendID",\n          type: "CHARARRAY",\n          value: "XXXX"\n        }, {\n          name: "fsSelection",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usFirstCharIndex",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usLastCharIndex",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "sTypoAscender",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "sTypoDescender",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "sTypoLineGap",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "usWinAscent",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usWinDescent",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "ulCodePageRange1",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "ulCodePageRange2",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "sxHeight",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "sCapHeight",\n          type: "SHORT",\n          value: 0\n        }, {\n          name: "usDefaultChar",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usBreakChar",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "usMaxContext",\n          type: "USHORT",\n          value: 0\n        }], e);\n      }\n\n      var parse = require("../parse"),\n          table = require("../table"),\n          unicodeRanges = [{\n        begin: 0,\n        end: 127\n      }, {\n        begin: 128,\n        end: 255\n      }, {\n        begin: 256,\n        end: 383\n      }, {\n        begin: 384,\n        end: 591\n      }, {\n        begin: 592,\n        end: 687\n      }, {\n        begin: 688,\n        end: 767\n      }, {\n        begin: 768,\n        end: 879\n      }, {\n        begin: 880,\n        end: 1023\n      }, {\n        begin: 11392,\n        end: 11519\n      }, {\n        begin: 1024,\n        end: 1279\n      }, {\n        begin: 1328,\n        end: 1423\n      }, {\n        begin: 1424,\n        end: 1535\n      }, {\n        begin: 42240,\n        end: 42559\n      }, {\n        begin: 1536,\n        end: 1791\n      }, {\n        begin: 1984,\n        end: 2047\n      }, {\n        begin: 2304,\n        end: 2431\n      }, {\n        begin: 2432,\n        end: 2559\n      }, {\n        begin: 2560,\n        end: 2687\n      }, {\n        begin: 2688,\n        end: 2815\n      }, {\n        begin: 2816,\n        end: 2943\n      }, {\n        begin: 2944,\n        end: 3071\n      }, {\n        begin: 3072,\n        end: 3199\n      }, {\n        begin: 3200,\n        end: 3327\n      }, {\n        begin: 3328,\n        end: 3455\n      }, {\n        begin: 3584,\n        end: 3711\n      }, {\n        begin: 3712,\n        end: 3839\n      }, {\n        begin: 4256,\n        end: 4351\n      }, {\n        begin: 6912,\n        end: 7039\n      }, {\n        begin: 4352,\n        end: 4607\n      }, {\n        begin: 7680,\n        end: 7935\n      }, {\n        begin: 7936,\n        end: 8191\n      }, {\n        begin: 8192,\n        end: 8303\n      }, {\n        begin: 8304,\n        end: 8351\n      }, {\n        begin: 8352,\n        end: 8399\n      }, {\n        begin: 8400,\n        end: 8447\n      }, {\n        begin: 8448,\n        end: 8527\n      }, {\n        begin: 8528,\n        end: 8591\n      }, {\n        begin: 8592,\n        end: 8703\n      }, {\n        begin: 8704,\n        end: 8959\n      }, {\n        begin: 8960,\n        end: 9215\n      }, {\n        begin: 9216,\n        end: 9279\n      }, {\n        begin: 9280,\n        end: 9311\n      }, {\n        begin: 9312,\n        end: 9471\n      }, {\n        begin: 9472,\n        end: 9599\n      }, {\n        begin: 9600,\n        end: 9631\n      }, {\n        begin: 9632,\n        end: 9727\n      }, {\n        begin: 9728,\n        end: 9983\n      }, {\n        begin: 9984,\n        end: 10175\n      }, {\n        begin: 12288,\n        end: 12351\n      }, {\n        begin: 12352,\n        end: 12447\n      }, {\n        begin: 12448,\n        end: 12543\n      }, {\n        begin: 12544,\n        end: 12591\n      }, {\n        begin: 12592,\n        end: 12687\n      }, {\n        begin: 43072,\n        end: 43135\n      }, {\n        begin: 12800,\n        end: 13055\n      }, {\n        begin: 13056,\n        end: 13311\n      }, {\n        begin: 44032,\n        end: 55215\n      }, {\n        begin: 55296,\n        end: 57343\n      }, {\n        begin: 67840,\n        end: 67871\n      }, {\n        begin: 19968,\n        end: 40959\n      }, {\n        begin: 57344,\n        end: 63743\n      }, {\n        begin: 12736,\n        end: 12783\n      }, {\n        begin: 64256,\n        end: 64335\n      }, {\n        begin: 64336,\n        end: 65023\n      }, {\n        begin: 65056,\n        end: 65071\n      }, {\n        begin: 65040,\n        end: 65055\n      }, {\n        begin: 65104,\n        end: 65135\n      }, {\n        begin: 65136,\n        end: 65279\n      }, {\n        begin: 65280,\n        end: 65519\n      }, {\n        begin: 65520,\n        end: 65535\n      }, {\n        begin: 3840,\n        end: 4095\n      }, {\n        begin: 1792,\n        end: 1871\n      }, {\n        begin: 1920,\n        end: 1983\n      }, {\n        begin: 3456,\n        end: 3583\n      }, {\n        begin: 4096,\n        end: 4255\n      }, {\n        begin: 4608,\n        end: 4991\n      }, {\n        begin: 5024,\n        end: 5119\n      }, {\n        begin: 5120,\n        end: 5759\n      }, {\n        begin: 5760,\n        end: 5791\n      }, {\n        begin: 5792,\n        end: 5887\n      }, {\n        begin: 6016,\n        end: 6143\n      }, {\n        begin: 6144,\n        end: 6319\n      }, {\n        begin: 10240,\n        end: 10495\n      }, {\n        begin: 40960,\n        end: 42127\n      }, {\n        begin: 5888,\n        end: 5919\n      }, {\n        begin: 66304,\n        end: 66351\n      }, {\n        begin: 66352,\n        end: 66383\n      }, {\n        begin: 66560,\n        end: 66639\n      }, {\n        begin: 118784,\n        end: 119039\n      }, {\n        begin: 119808,\n        end: 120831\n      }, {\n        begin: 1044480,\n        end: 1048573\n      }, {\n        begin: 65024,\n        end: 65039\n      }, {\n        begin: 917504,\n        end: 917631\n      }, {\n        begin: 6400,\n        end: 6479\n      }, {\n        begin: 6480,\n        end: 6527\n      }, {\n        begin: 6528,\n        end: 6623\n      }, {\n        begin: 6656,\n        end: 6687\n      }, {\n        begin: 11264,\n        end: 11359\n      }, {\n        begin: 11568,\n        end: 11647\n      }, {\n        begin: 19904,\n        end: 19967\n      }, {\n        begin: 43008,\n        end: 43055\n      }, {\n        begin: 65536,\n        end: 65663\n      }, {\n        begin: 65856,\n        end: 65935\n      }, {\n        begin: 66432,\n        end: 66463\n      }, {\n        begin: 66464,\n        end: 66527\n      }, {\n        begin: 66640,\n        end: 66687\n      }, {\n        begin: 66688,\n        end: 66735\n      }, {\n        begin: 67584,\n        end: 67647\n      }, {\n        begin: 68096,\n        end: 68191\n      }, {\n        begin: 119552,\n        end: 119647\n      }, {\n        begin: 73728,\n        end: 74751\n      }, {\n        begin: 119648,\n        end: 119679\n      }, {\n        begin: 7040,\n        end: 7103\n      }, {\n        begin: 7168,\n        end: 7247\n      }, {\n        begin: 7248,\n        end: 7295\n      }, {\n        begin: 43136,\n        end: 43231\n      }, {\n        begin: 43264,\n        end: 43311\n      }, {\n        begin: 43312,\n        end: 43359\n      }, {\n        begin: 43520,\n        end: 43615\n      }, {\n        begin: 65936,\n        end: 65999\n      }, {\n        begin: 66e3,\n        end: 66047\n      }, {\n        begin: 66208,\n        end: 66271\n      }, {\n        begin: 127024,\n        end: 127135\n      }];\n\n      exports.unicodeRanges = unicodeRanges, exports.getUnicodeRange = getUnicodeRange, exports.parse = parseOS2Table, exports.make = makeOS2Table;\n    }, {\n      "../parse": 10,\n      "../table": 13\n    }],\n    30: [function (require, module, exports) {\n      "use strict";\n\n      function parsePostTable(e, a) {\n        var r,\n            n = {},\n            s = new parse.Parser(e, a);\n\n        switch (n.version = s.parseVersion(), n.italicAngle = s.parseFixed(), n.underlinePosition = s.parseShort(), n.underlineThickness = s.parseShort(), n.isFixedPitch = s.parseULong(), n.minMemType42 = s.parseULong(), n.maxMemType42 = s.parseULong(), n.minMemType1 = s.parseULong(), n.maxMemType1 = s.parseULong(), n.version) {\n          case 1:\n            n.names = encoding.standardNames.slice();\n            break;\n\n          case 2:\n            for (n.numberOfGlyphs = s.parseUShort(), n.glyphNameIndex = new Array(n.numberOfGlyphs), r = 0; r < n.numberOfGlyphs; r++) {\n              n.glyphNameIndex[r] = s.parseUShort();\n            }\n\n            for (n.names = [], r = 0; r < n.numberOfGlyphs; r++) {\n              if (n.glyphNameIndex[r] >= encoding.standardNames.length) {\n                var p = s.parseChar();\n                n.names.push(s.parseString(p));\n              }\n            }\n\n            break;\n\n          case 2.5:\n            for (n.numberOfGlyphs = s.parseUShort(), n.offset = new Array(n.numberOfGlyphs), r = 0; r < n.numberOfGlyphs; r++) {\n              n.offset[r] = s.parseChar();\n            }\n\n        }\n\n        return n;\n      }\n\n      function makePostTable() {\n        return new table.Table("post", [{\n          name: "version",\n          type: "FIXED",\n          value: 196608\n        }, {\n          name: "italicAngle",\n          type: "FIXED",\n          value: 0\n        }, {\n          name: "underlinePosition",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "underlineThickness",\n          type: "FWORD",\n          value: 0\n        }, {\n          name: "isFixedPitch",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "minMemType42",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "maxMemType42",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "minMemType1",\n          type: "ULONG",\n          value: 0\n        }, {\n          name: "maxMemType1",\n          type: "ULONG",\n          value: 0\n        }]);\n      }\n\n      var encoding = require("../encoding"),\n          parse = require("../parse"),\n          table = require("../table");\n\n      exports.parse = parsePostTable, exports.make = makePostTable;\n    }, {\n      "../encoding": 4,\n      "../parse": 10,\n      "../table": 13\n    }],\n    31: [function (require, module, exports) {\n      "use strict";\n\n      function log2(e) {\n        return Math.log(e) / Math.log(2) | 0;\n      }\n\n      function computeCheckSum(e) {\n        for (; e.length % 4 !== 0;) {\n          e.push(0);\n        }\n\n        for (var a = 0, n = 0; n < e.length; n += 4) {\n          a += (e[n] << 24) + (e[n + 1] << 16) + (e[n + 2] << 8) + e[n + 3];\n        }\n\n        return a %= Math.pow(2, 32);\n      }\n\n      function makeTableRecord(e, a, n, t) {\n        return new table.Record("Table Record", [{\n          name: "tag",\n          type: "TAG",\n          value: void 0 !== e ? e : ""\n        }, {\n          name: "checkSum",\n          type: "ULONG",\n          value: void 0 !== a ? a : 0\n        }, {\n          name: "offset",\n          type: "ULONG",\n          value: void 0 !== n ? n : 0\n        }, {\n          name: "length",\n          type: "ULONG",\n          value: void 0 !== t ? t : 0\n        }]);\n      }\n\n      function makeSfntTable(e) {\n        var a = new table.Table("sfnt", [{\n          name: "version",\n          type: "TAG",\n          value: "OTTO"\n        }, {\n          name: "numTables",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "searchRange",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "entrySelector",\n          type: "USHORT",\n          value: 0\n        }, {\n          name: "rangeShift",\n          type: "USHORT",\n          value: 0\n        }]);\n        a.tables = e, a.numTables = e.length;\n        var n = Math.pow(2, log2(a.numTables));\n        a.searchRange = 16 * n, a.entrySelector = log2(n), a.rangeShift = 16 * a.numTables - a.searchRange;\n\n        for (var t = [], r = [], i = a.sizeOf() + makeTableRecord().sizeOf() * a.numTables; i % 4 !== 0;) {\n          i += 1, r.push({\n            name: "padding",\n            type: "BYTE",\n            value: 0\n          });\n        }\n\n        for (var s = 0; s < e.length; s += 1) {\n          var l = e[s];\n          check.argument(4 === l.tableName.length, "Table name" + l.tableName + " is invalid.");\n          var u = l.sizeOf(),\n              m = makeTableRecord(l.tableName, computeCheckSum(l.encode()), i, u);\n\n          for (t.push({\n            name: m.tag + " Table Record",\n            type: "RECORD",\n            value: m\n          }), r.push({\n            name: l.tableName + " table",\n            type: "RECORD",\n            value: l\n          }), i += u, check.argument(!isNaN(i), "Something went wrong calculating the offset."); i % 4 !== 0;) {\n            i += 1, r.push({\n              name: "padding",\n              type: "BYTE",\n              value: 0\n            });\n          }\n        }\n\n        return t.sort(function (e, a) {\n          return e.value.tag > a.value.tag ? 1 : -1;\n        }), a.fields = a.fields.concat(t), a.fields = a.fields.concat(r), a;\n      }\n\n      function metricsForChar(e, a, n) {\n        for (var t = 0; t < a.length; t += 1) {\n          var r = e.charToGlyphIndex(a[t]);\n\n          if (r > 0) {\n            var i = e.glyphs.get(r);\n            return i.getMetrics();\n          }\n        }\n\n        return n;\n      }\n\n      function average(e) {\n        for (var a = 0, n = 0; n < e.length; n += 1) {\n          a += e[n];\n        }\n\n        return a / e.length;\n      }\n\n      function fontToSfntTable(e) {\n        for (var a, n = [], t = [], r = [], i = [], s = [], l = [], u = [], m = 0, h = 0, o = 0, c = 0, d = 0, g = 0; g < e.glyphs.length; g += 1) {\n          var p = e.glyphs.get(g),\n              f = 0 | p.unicode;\n          if (isNaN(p.advanceWidth)) throw new Error("Glyph " + p.name + " (" + g + "): advanceWidth is not a number.");\n          (a > f || void 0 === a) && f > 0 && (a = f), f > m && (m = f);\n          var v = os2.getUnicodeRange(f);\n          if (32 > v) h |= 1 << v;else if (64 > v) o |= 1 << v - 32;else if (96 > v) c |= 1 << v - 64;else {\n            if (!(123 > v)) throw new Error("Unicode ranges bits > 123 are reserved for internal usage");\n            d |= 1 << v - 96;\n          }\n\n          if (".notdef" !== p.name) {\n            var y = p.getMetrics();\n            n.push(y.xMin), t.push(y.yMin), r.push(y.xMax), i.push(y.yMax), l.push(y.leftSideBearing), u.push(y.rightSideBearing), s.push(p.advanceWidth);\n          }\n        }\n\n        var x = {\n          xMin: Math.min.apply(null, n),\n          yMin: Math.min.apply(null, t),\n          xMax: Math.max.apply(null, r),\n          yMax: Math.max.apply(null, i),\n          advanceWidthMax: Math.max.apply(null, s),\n          advanceWidthAvg: average(s),\n          minLeftSideBearing: Math.min.apply(null, l),\n          maxLeftSideBearing: Math.max.apply(null, l),\n          minRightSideBearing: Math.min.apply(null, u)\n        };\n        x.ascender = e.ascender, x.descender = e.descender;\n        var b = head.make({\n          flags: 3,\n          unitsPerEm: e.unitsPerEm,\n          xMin: x.xMin,\n          yMin: x.yMin,\n          xMax: x.xMax,\n          yMax: x.yMax,\n          lowestRecPPEM: 3,\n          createdTimestamp: e.createdTimestamp\n        }),\n            M = hhea.make({\n          ascender: x.ascender,\n          descender: x.descender,\n          advanceWidthMax: x.advanceWidthMax,\n          minLeftSideBearing: x.minLeftSideBearing,\n          minRightSideBearing: x.minRightSideBearing,\n          xMaxExtent: x.maxLeftSideBearing + (x.xMax - x.xMin),\n          numberOfHMetrics: e.glyphs.length\n        }),\n            S = maxp.make(e.glyphs.length),\n            T = os2.make({\n          xAvgCharWidth: Math.round(x.advanceWidthAvg),\n          usWeightClass: e.tables.os2.usWeightClass,\n          usWidthClass: e.tables.os2.usWidthClass,\n          usFirstCharIndex: a,\n          usLastCharIndex: m,\n          ulUnicodeRange1: h,\n          ulUnicodeRange2: o,\n          ulUnicodeRange3: c,\n          ulUnicodeRange4: d,\n          fsSelection: e.tables.os2.fsSelection,\n          sTypoAscender: x.ascender,\n          sTypoDescender: x.descender,\n          sTypoLineGap: 0,\n          usWinAscent: x.yMax,\n          usWinDescent: Math.abs(x.yMin),\n          ulCodePageRange1: 1,\n          sxHeight: metricsForChar(e, "xyvw", {\n            yMax: Math.round(x.ascender / 2)\n          }).yMax,\n          sCapHeight: metricsForChar(e, "HIKLEFJMNTZBDPRAGOQSUVWXY", x).yMax,\n          usDefaultChar: e.hasChar(" ") ? 32 : 0,\n          usBreakChar: e.hasChar(" ") ? 32 : 0\n        }),\n            k = hmtx.make(e.glyphs),\n            R = cmap.make(e.glyphs),\n            C = e.getEnglishName("fontFamily"),\n            N = e.getEnglishName("fontSubfamily"),\n            E = C + " " + N,\n            O = e.getEnglishName("postScriptName");\n        O || (O = C.replace(/\\s/g, "") + "-" + N);\n        var W = {};\n\n        for (var q in e.names) {\n          W[q] = e.names[q];\n        }\n\n        W.uniqueID || (W.uniqueID = {\n          en: e.getEnglishName("manufacturer") + ":" + E\n        }), W.postScriptName || (W.postScriptName = {\n          en: O\n        }), W.preferredFamily || (W.preferredFamily = e.names.fontFamily), W.preferredSubfamily || (W.preferredSubfamily = e.names.fontSubfamily);\n\n        var w = [],\n            B = _name.make(W, w),\n            U = w.length > 0 ? ltag.make(w) : void 0,\n            L = post.make(),\n            A = cff.make(e.glyphs, {\n          version: e.getEnglishName("version"),\n          fullName: E,\n          familyName: C,\n          weightName: N,\n          postScriptName: O,\n          unitsPerEm: e.unitsPerEm,\n          fontBBox: [0, x.yMin, x.ascender, x.advanceWidthMax]\n        }),\n            F = e.metas && Object.keys(e.metas).length > 0 ? meta.make(e.metas) : void 0,\n            G = [b, M, S, T, B, R, L, A, k];\n\n        U && G.push(U), e.tables.gsub && G.push(gsub.make(e.tables.gsub)), F && G.push(F);\n        var D = makeSfntTable(G),\n            H = D.encode(),\n            P = computeCheckSum(H),\n            I = D.fields,\n            j = !1;\n\n        for (g = 0; g < I.length; g += 1) {\n          if ("head table" === I[g].name) {\n            I[g].value.checkSumAdjustment = 2981146554 - P, j = !0;\n            break;\n          }\n        }\n\n        if (!j) throw new Error("Could not find head table with checkSum to adjust.");\n        return D;\n      }\n\n      var check = require("../check"),\n          table = require("../table"),\n          cmap = require("./cmap"),\n          cff = require("./cff"),\n          head = require("./head"),\n          hhea = require("./hhea"),\n          hmtx = require("./hmtx"),\n          ltag = require("./ltag"),\n          maxp = require("./maxp"),\n          _name = require("./name"),\n          os2 = require("./os2"),\n          post = require("./post"),\n          gsub = require("./gsub"),\n          meta = require("./meta");\n\n      exports.computeCheckSum = computeCheckSum, exports.make = makeSfntTable, exports.fontToTable = fontToSfntTable;\n    }, {\n      "../check": 2,\n      "../table": 13,\n      "./cff": 14,\n      "./cmap": 15,\n      "./gsub": 19,\n      "./head": 20,\n      "./hhea": 21,\n      "./hmtx": 22,\n      "./ltag": 25,\n      "./maxp": 26,\n      "./meta": 27,\n      "./name": 28,\n      "./os2": 29,\n      "./post": 30\n    }],\n    32: [function (require, module, exports) {\n      "use strict";\n\n      function constant(e) {\n        return function () {\n          return e;\n        };\n      }\n\n      var check = require("./check"),\n          LIMIT16 = 32768,\n          LIMIT32 = 2147483648,\n          decode = {},\n          encode = {},\n          sizeOf = {};\n\n      encode.BYTE = function (e) {\n        return check.argument(e >= 0 && 255 >= e, "Byte value should be between 0 and 255."), [e];\n      }, sizeOf.BYTE = constant(1), encode.CHAR = function (e) {\n        return [e.charCodeAt(0)];\n      }, sizeOf.CHAR = constant(1), encode.CHARARRAY = function (e) {\n        for (var n = [], t = 0; t < e.length; t += 1) {\n          n[t] = e.charCodeAt(t);\n        }\n\n        return n;\n      }, sizeOf.CHARARRAY = function (e) {\n        return e.length;\n      }, encode.USHORT = function (e) {\n        return [e >> 8 & 255, 255 & e];\n      }, sizeOf.USHORT = constant(2), encode.SHORT = function (e) {\n        return e >= LIMIT16 && (e = -(2 * LIMIT16 - e)), [e >> 8 & 255, 255 & e];\n      }, sizeOf.SHORT = constant(2), encode.UINT24 = function (e) {\n        return [e >> 16 & 255, e >> 8 & 255, 255 & e];\n      }, sizeOf.UINT24 = constant(3), encode.ULONG = function (e) {\n        return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n      }, sizeOf.ULONG = constant(4), encode.LONG = function (e) {\n        return e >= LIMIT32 && (e = -(2 * LIMIT32 - e)), [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n      }, sizeOf.LONG = constant(4), encode.FIXED = encode.ULONG, sizeOf.FIXED = sizeOf.ULONG, encode.FWORD = encode.SHORT, sizeOf.FWORD = sizeOf.SHORT, encode.UFWORD = encode.USHORT, sizeOf.UFWORD = sizeOf.USHORT, encode.LONGDATETIME = function (e) {\n        return [0, 0, 0, 0, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n      }, sizeOf.LONGDATETIME = constant(8), encode.TAG = function (e) {\n        return check.argument(4 === e.length, "Tag should be exactly 4 ASCII characters."), [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)];\n      }, sizeOf.TAG = constant(4), encode.Card8 = encode.BYTE, sizeOf.Card8 = sizeOf.BYTE, encode.Card16 = encode.USHORT, sizeOf.Card16 = sizeOf.USHORT, encode.OffSize = encode.BYTE, sizeOf.OffSize = sizeOf.BYTE, encode.SID = encode.USHORT, sizeOf.SID = sizeOf.USHORT, encode.NUMBER = function (e) {\n        return e >= -107 && 107 >= e ? [e + 139] : e >= 108 && 1131 >= e ? (e -= 108, [(e >> 8) + 247, 255 & e]) : e >= -1131 && -108 >= e ? (e = -e - 108, [(e >> 8) + 251, 255 & e]) : e >= -32768 && 32767 >= e ? encode.NUMBER16(e) : encode.NUMBER32(e);\n      }, sizeOf.NUMBER = function (e) {\n        return encode.NUMBER(e).length;\n      }, encode.NUMBER16 = function (e) {\n        return [28, e >> 8 & 255, 255 & e];\n      }, sizeOf.NUMBER16 = constant(3), encode.NUMBER32 = function (e) {\n        return [29, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e];\n      }, sizeOf.NUMBER32 = constant(5), encode.REAL = function (e) {\n        var n = e.toString(),\n            t = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(n);\n\n        if (t) {\n          var o = parseFloat("1e" + ((t[2] ? +t[2] : 0) + t[1].length));\n          n = (Math.round(e * o) / o).toString();\n        }\n\n        var c,\n            r,\n            i = "";\n\n        for (c = 0, r = n.length; r > c; c += 1) {\n          var a = n[c];\n          i += "e" === a ? "-" === n[++c] ? "c" : "b" : "." === a ? "a" : "-" === a ? "e" : a;\n        }\n\n        i += 1 & i.length ? "f" : "ff";\n        var f = [30];\n\n        for (c = 0, r = i.length; r > c; c += 2) {\n          f.push(parseInt(i.substr(c, 2), 16));\n        }\n\n        return f;\n      }, sizeOf.REAL = function (e) {\n        return encode.REAL(e).length;\n      }, encode.NAME = encode.CHARARRAY, sizeOf.NAME = sizeOf.CHARARRAY, encode.STRING = encode.CHARARRAY, sizeOf.STRING = sizeOf.CHARARRAY, decode.UTF8 = function (e, n, t) {\n        for (var o = [], c = t, r = 0; c > r; r++, n += 1) {\n          o[r] = e.getUint8(n);\n        }\n\n        return String.fromCharCode.apply(null, o);\n      }, decode.UTF16 = function (e, n, t) {\n        for (var o = [], c = t / 2, r = 0; c > r; r++, n += 2) {\n          o[r] = e.getUint16(n);\n        }\n\n        return String.fromCharCode.apply(null, o);\n      }, encode.UTF16 = function (e) {\n        for (var n = [], t = 0; t < e.length; t += 1) {\n          var o = e.charCodeAt(t);\n          n[n.length] = o >> 8 & 255, n[n.length] = 255 & o;\n        }\n\n        return n;\n      }, sizeOf.UTF16 = function (e) {\n        return 2 * e.length;\n      };\n      var eightBitMacEncodings = {\n        "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",\n        "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю",\n        "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ",\n        "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­",\n        "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",\n        "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",\n        "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",\n        macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",\n        "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",\n        "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"\n      };\n\n      decode.MACSTRING = function (e, n, t, o) {\n        var c = eightBitMacEncodings[o];\n        if (void 0 === c) return void 0;\n\n        for (var r = "", i = 0; t > i; i++) {\n          var a = e.getUint8(n + i);\n          r += 127 >= a ? String.fromCharCode(a) : c[127 & a];\n        }\n\n        return r;\n      };\n\n      var macEncodingTableCache = "function" == typeof WeakMap && new WeakMap(),\n          macEncodingCacheKeys,\n          getMacEncodingTable = function getMacEncodingTable(e) {\n        if (!macEncodingCacheKeys) {\n          macEncodingCacheKeys = {};\n\n          for (var n in eightBitMacEncodings) {\n            macEncodingCacheKeys[n] = new String(n);\n          }\n        }\n\n        var t = macEncodingCacheKeys[e];\n        if (void 0 === t) return void 0;\n\n        if (macEncodingTableCache) {\n          var o = macEncodingTableCache.get(t);\n          if (void 0 !== o) return o;\n        }\n\n        var c = eightBitMacEncodings[e];\n        if (void 0 === c) return void 0;\n\n        for (var r = {}, i = 0; i < c.length; i++) {\n          r[c.charCodeAt(i)] = i + 128;\n        }\n\n        return macEncodingTableCache && macEncodingTableCache.set(t, r), r;\n      };\n\n      encode.MACSTRING = function (e, n) {\n        var t = getMacEncodingTable(n);\n        if (void 0 === t) return void 0;\n\n        for (var o = [], c = 0; c < e.length; c++) {\n          var r = e.charCodeAt(c);\n          if (r >= 128 && (r = t[r], void 0 === r)) return void 0;\n          o[c] = r;\n        }\n\n        return o;\n      }, sizeOf.MACSTRING = function (e, n) {\n        var t = encode.MACSTRING(e, n);\n        return void 0 !== t ? t.length : 0;\n      }, encode.INDEX = function (e) {\n        var n,\n            t = 1,\n            o = [t],\n            c = [];\n\n        for (n = 0; n < e.length; n += 1) {\n          var r = encode.OBJECT(e[n]);\n          Array.prototype.push.apply(c, r), t += r.length, o.push(t);\n        }\n\n        if (0 === c.length) return [0, 0];\n        var i = [],\n            a = 1 + Math.floor(Math.log(t) / Math.log(2)) / 8 | 0,\n            f = [void 0, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][a];\n\n        for (n = 0; n < o.length; n += 1) {\n          var d = f(o[n]);\n          Array.prototype.push.apply(i, d);\n        }\n\n        return Array.prototype.concat(encode.Card16(e.length), encode.OffSize(a), i, c);\n      }, sizeOf.INDEX = function (e) {\n        return encode.INDEX(e).length;\n      }, encode.DICT = function (e) {\n        for (var n = [], t = Object.keys(e), o = t.length, c = 0; o > c; c += 1) {\n          var r = parseInt(t[c], 0),\n              i = e[r];\n          n = n.concat(encode.OPERAND(i.value, i.type)), n = n.concat(encode.OPERATOR(r));\n        }\n\n        return n;\n      }, sizeOf.DICT = function (e) {\n        return encode.DICT(e).length;\n      }, encode.OPERATOR = function (e) {\n        return 1200 > e ? [e] : [12, e - 1200];\n      }, encode.OPERAND = function (e, n) {\n        var t = [];\n        if (Array.isArray(n)) for (var o = 0; o < n.length; o += 1) {\n          check.argument(e.length === n.length, "Not enough arguments given for type" + n), t = t.concat(encode.OPERAND(e[o], n[o]));\n        } else if ("SID" === n) t = t.concat(encode.NUMBER(e));else if ("offset" === n) t = t.concat(encode.NUMBER32(e));else if ("number" === n) t = t.concat(encode.NUMBER(e));else {\n          if ("real" !== n) throw new Error("Unknown operand type " + n);\n          t = t.concat(encode.REAL(e));\n        }\n        return t;\n      }, encode.OP = encode.BYTE, sizeOf.OP = sizeOf.BYTE;\n      var wmm = "function" == typeof WeakMap && new WeakMap();\n      encode.CHARSTRING = function (e) {\n        if (wmm) {\n          var n = wmm.get(e);\n          if (void 0 !== n) return n;\n        }\n\n        for (var t = [], o = e.length, c = 0; o > c; c += 1) {\n          var r = e[c];\n          t = t.concat(encode[r.type](r.value));\n        }\n\n        return wmm && wmm.set(e, t), t;\n      }, sizeOf.CHARSTRING = function (e) {\n        return encode.CHARSTRING(e).length;\n      }, encode.OBJECT = function (e) {\n        var n = encode[e.type];\n        return check.argument(void 0 !== n, "No encoding function for type " + e.type), n(e.value);\n      }, sizeOf.OBJECT = function (e) {\n        var n = sizeOf[e.type];\n        return check.argument(void 0 !== n, "No sizeOf function for type " + e.type), n(e.value);\n      }, encode.TABLE = function (e) {\n        var n,\n            t = [],\n            o = e.fields.length,\n            c = [],\n            r = [];\n\n        for (n = 0; o > n; n += 1) {\n          var i = e.fields[n],\n              a = encode[i.type];\n          check.argument(void 0 !== a, "No encoding function for field type " + i.type + " (" + i.name + ")");\n          var f = e[i.name];\n          void 0 === f && (f = i.value);\n          var d = a(f);\n          "TABLE" === i.type ? (r.push(t.length), t = t.concat([0, 0]), c.push(d)) : t = t.concat(d);\n        }\n\n        for (n = 0; n < c.length; n += 1) {\n          var u = r[n],\n              s = t.length;\n          check.argument(65536 > s, "Table " + e.tableName + " too big."), t[u] = s >> 8, t[u + 1] = 255 & s, t = t.concat(c[n]);\n        }\n\n        return t;\n      }, sizeOf.TABLE = function (e) {\n        for (var n = 0, t = e.fields.length, o = 0; t > o; o += 1) {\n          var c = e.fields[o],\n              r = sizeOf[c.type];\n          check.argument(void 0 !== r, "No sizeOf function for field type " + c.type + " (" + c.name + ")");\n          var i = e[c.name];\n          void 0 === i && (i = c.value), n += r(i), "TABLE" === c.type && (n += 2);\n        }\n\n        return n;\n      }, encode.RECORD = encode.TABLE, sizeOf.RECORD = sizeOf.TABLE, encode.LITERAL = function (e) {\n        return e;\n      }, sizeOf.LITERAL = function (e) {\n        return e.length;\n      }, exports.decode = decode, exports.encode = encode, exports.sizeOf = sizeOf;\n    }, {\n      "./check": 2\n    }],\n    33: [function (require, module, exports) {\n      "use strict";\n\n      exports.isBrowser = function () {\n        return "undefined" != typeof window;\n      }, exports.isNode = function () {\n        return "undefined" == typeof window;\n      }, exports.nodeBufferToArrayBuffer = function (r) {\n        for (var e = new ArrayBuffer(r.length), n = new Uint8Array(e), t = 0; t < r.length; ++t) {\n          n[t] = r[t];\n        }\n\n        return e;\n      }, exports.arrayBufferToNodeBuffer = function (r) {\n        for (var e = new Buffer(r.byteLength), n = new Uint8Array(r), t = 0; t < e.length; ++t) {\n          e[t] = n[t];\n        }\n\n        return e;\n      }, exports.checkArgument = function (r, e) {\n        if (!r) throw e;\n      };\n    }, {}]\n  }, {}, [9])(9);\n});\n\nvar opentype = window.opentype;\n\n//# sourceURL=webpack://font-research/./src/Lib/opentype.module.min.js?')},"./src/Lib/scoreoutputer.min.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n!function (e, n) {\n  "object" == ( false ? 0 : _typeof(exports)) && "undefined" != "object" ? module.exports = n() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (n),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n}(this, function () {\n  "use strict";\n\n  function e(e, n) {\n    if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function");\n  }\n\n  function n(e, n) {\n    for (var t = 0; t < n.length; t++) {\n      var o = n[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n    }\n  }\n\n  function t(e, n) {\n    (null == n || n > e.length) && (n = e.length);\n\n    for (var t = 0, o = new Array(n); t < n; t++) {\n      o[t] = e[t];\n    }\n\n    return o;\n  }\n\n  function o(e, n) {\n    var o = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];\n\n    if (!o) {\n      if (Array.isArray(e) || (o = function (e, n) {\n        if (e) {\n          if ("string" == typeof e) return t(e, n);\n          var o = Object.prototype.toString.call(e).slice(8, -1);\n          return "Object" === o && e.constructor && (o = e.constructor.name), "Map" === o || "Set" === o ? Array.from(e) : "Arguments" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? t(e, n) : void 0;\n        }\n      }(e)) || n && e && "number" == typeof e.length) {\n        o && (e = o);\n\n        var i = 0,\n            a = function a() {};\n\n        return {\n          s: a,\n          n: function n() {\n            return i >= e.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: e[i++]\n            };\n          },\n          e: function e(_e) {\n            throw _e;\n          },\n          f: a\n        };\n      }\n\n      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n    }\n\n    var r,\n        l = !0,\n        d = !1;\n    return {\n      s: function s() {\n        o = o.call(e);\n      },\n      n: function n() {\n        var e = o.next();\n        return l = e.done, e;\n      },\n      e: function e(_e2) {\n        d = !0, r = _e2;\n      },\n      f: function f() {\n        try {\n          l || null == o["return"] || o["return"]();\n        } finally {\n          if (d) throw r;\n        }\n      }\n    };\n  }\n\n  var i = function i(e) {\n    var n = e.backgroundColor,\n        t = e.color,\n        i = e.fontSize,\n        a = e.fsFontSize,\n        r = e.dialogTitle,\n        l = e.childArr,\n        d = document.createElement("div");\n    d.classList.add("modal", "fade"), d.style.backgroundColor = "#0000008f", d.isShow = !1;\n    var s = document.createElement("div");\n    s.classList.add("modal-dialog"), d.appendChild(s);\n    var c = document.createElement("div");\n    c.classList.add("modal-content"), c.addEventListener("click", function (e) {\n      e.stopPropagation();\n    }), s.appendChild(c);\n    var p = document.createElement("div");\n    p.classList.add("modal-header", "_tpqqqwepiqopwef"), p.style.backgroundColor = n, p.style.color = t;\n    var f = document.createElement("h5");\n    f.classList.add("modal-title"), f.innerText = r, p.appendChild(f);\n    var h = document.createElement("div");\n    h.classList.add("modal-body", "_tpqqqwepiqopwef"), h.style.backgroundColor = n, h.style.color = t;\n    var u = document.createElement("table");\n    u.classList.add("bw8e4f98w"), u.style.fontSize = i;\n    var m = document.createElement("tbody");\n    u.appendChild(m), h.appendChild(u);\n\n    for (var v = document.createElement("tr"), w = 0, b = ["總分", "完成後打勾", "配分", "分項描述"]; w < b.length; w++) {\n      var y = b[w],\n          g = document.createElement("th");\n      g.classList.add("woiejfwiojf"), g.innerText = y, v.appendChild(g);\n    }\n\n    m.appendChild(v);\n    var k = document.createElement("td");\n    k.classList.add("woiejfwiojf"), k.innerText = "0", k.rowSpan = 7;\n\n    for (var x = [], E = 0; E < l.length; E++) {\n      var C = document.createElement("tr");\n      0 == E && C.appendChild(k);\n      var L = document.createElement("td");\n      L.classList.add("woiejfwiojf");\n      var T = document.createElement("input");\n      T.type = "checkbox", T.checked = l[E].checked, T.classList.add("flipswitch", "wskfgakjiopfhu"), T.style.fontSize = a, L.appendChild(T);\n      var j = document.createElement("td");\n      j.classList.add("woiejfwiojf"), j.innerText = l[E].points, j.points = l[E].points, T.checked && (k.innerText = +k.innerText + l[E].points);\n      var q = document.createElement("td");\n      q.classList.add("woiejfwiojf"), q.innerText = l[E].name, q.name = l[E].name, C.appendChild(L), C.appendChild(j), C.appendChild(q), x.push({\n        checkbox: T,\n        points: j,\n        name: q\n      });\n      var S,\n          A = o(x);\n\n      try {\n        for (A.s(); !(S = A.n()).done;) {\n          S.value.checkbox.addEventListener("change", function (e) {\n            var n,\n                t = 0,\n                i = o(x);\n\n            try {\n              for (i.s(); !(n = i.n()).done;) {\n                var a = n.value;\n                a.checkbox.checked && (t += a.points.points);\n              }\n            } catch (e) {\n              i.e(e);\n            } finally {\n              i.f();\n            }\n\n            k.innerText = t;\n          });\n        }\n      } catch (e) {\n        A.e(e);\n      } finally {\n        A.f();\n      }\n\n      m.appendChild(C);\n    }\n\n    var B = document.createElement("div");\n    B.classList.add("modal-footer", "_tpqqqwepiqopwef"), B.style.backgroundColor = n, B.style.color = t, c.appendChild(p), c.appendChild(h), c.appendChild(B);\n    var z = document.createElement("a");\n    z.innerText = "匯出 CSV", z.classList.add("btn", "btn-primary");\n\n    var _ = document.createElement("a");\n\n    return _.classList.add("btn", "btn-secondary"), _.innerText = "關閉", _.addEventListener("click", function (e) {\n      e.preventDefault(), d.classList.remove("show"), setTimeout(function () {\n        d.style.display = "none";\n      }, 200), d.isShow = !1;\n    }), window.addEventListener("keydown", function (e) {\n      console.log(), "Escape" == e.key && (d.classList.remove("show"), setTimeout(function () {\n        d.style.display = "none";\n      }, 200), d.isShow = !1);\n    }), B.appendChild(z), B.appendChild(_), {\n      items: x,\n      downloadCsvBtn: z,\n      closeBtn: _,\n      modal: d\n    };\n  },\n      a = "\\n@import url(\'https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@900&display=swap\');\\n\\n    \\n\\n\\n    .modal-body._tpqqqwepiqopwef, .modal-header._tpqqqwepiqopwef, .modal-footer._tpqqqwepiqopwef {\\n        font-family: \'Noto Serif JP\', sans-serif;\\n    }\\n\\n    table.bw8e4f98w {\\n        border-collapse: collapse;\\n        border-width: 2px;\\n        border-style: solid;\\n        border-color: white;\\n        margin-left: auto;\\n        margin-right: auto;\\n    }\\n\\n    td.woiejfwiojf,\\n    th.woiejfwiojf {\\n        border-width: 1px;\\n        border-style: solid;\\n        border-color: white;\\n        padding: 2px 8px;\\n    }\\n\\n    .flipswitch.wskfgakjiopfhu {\\n        position: relative;\\n        background: white;\\n        width: 120px;\\n        height: 20px;\\n        -webkit-appearance: initial;\\n        border-radius: 3px;\\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n        outline:none;\\n        font-family: Trebuchet, Arial, sans-serif;\\n        font-weight: bold;\\n        cursor:pointer;\\n        border:1px solid #ddd;\\n    }\\n    .flipswitch.wskfgakjiopfhu:after {\\n        position:absolute;\\n        top:5%;\\n        display:block; \\n        line-height:16px;\\n        width:45%;\\n        height:90%;\\n        background:#fff;\\n        box-sizing:border-box;\\n        text-align:center;\\n        transition: all 0.3s ease-in 0s; \\n        color:rgba(159,53,58,1);\\n        border:#888 1px solid;\\n        border-radius:3px;\\n    }\\n    .flipswitch.wskfgakjiopfhu:after {\\n        left:2%;\\n        content: \\"未完成\\";\\n    }\\n    .flipswitch.wskfgakjiopfhu:checked:after {\\n        left:53%;\\n        content: \\"完成\\";\\n    }\\n\\n";\n\n  return function () {\n    function t() {\n      var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "測試";\n      e(this, t), this.items = null, this.dBtn = null, this.modal = null, this.closeBtn = null, this.childArr = null, this.fileName = n;\n      var o = document.createTextNode(a),\n          i = document.createElement("style");\n      i.appendChild(o), document.head.appendChild(i);\n    }\n\n    var r, l, d;\n    return r = t, (l = [{\n      key: "addChild",\n      value: function value(e, n) {\n        var t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        null === this.childArr && (this.childArr = []), this.childArr.push({\n          name: e,\n          points: n,\n          checked: t\n        });\n      }\n    }, {\n      key: "renderModal",\n      value: function value(e) {\n        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "rgba(159,53,58,1)",\n            t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "white",\n            o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "12pt",\n            a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "14px",\n            r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "自我評分表 (供助教參考)";\n        if (null !== this.childArr) {\n          if (e instanceof HTMLElement) {\n            var l = i({\n              backgroundColor: n,\n              color: t,\n              fontSize: o,\n              fsFontSize: a,\n              dialogTitle: r,\n              childArr: this.childArr\n            }),\n                d = l.items,\n                s = l.downloadCsvBtn,\n                c = l.modal,\n                p = l.closeBtn;\n            this.items = d, this.dBtn = s, this.modal = c, this.closeBtn = p, e.appendChild(c);\n          } else console.error("Target Element is not a valid html element");\n        } else console.error("Child elements not add");\n      }\n    }, {\n      key: "installCSS",\n      value: function value(e) {\n        var n = document.createElement("link");\n        n.href = "https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css", n.rel = "stylesheet", document.head.appendChild(n), "function" == typeof e && n.addEventListener("load", e);\n      }\n    }, {\n      key: "installDownloadBtn",\n      value: function value() {\n        if (null !== this.modal) {\n          var e = this.items,\n              n = this.fileName;\n          this.dBtn.addEventListener("click", function (t) {\n            var i = function () {\n              var n,\n                  t = [],\n                  i = [],\n                  a = 0,\n                  r = o(e);\n\n              try {\n                for (r.s(); !(n = r.n()).done;) {\n                  var l = n.value,\n                      d = l.checkbox,\n                      s = l.points,\n                      c = l.name;\n                  t.push("".concat(c.name, "/").concat(s.points)), i.push(+d.checked), d.checked && (a += s.points);\n                }\n              } catch (e) {\n                r.e(e);\n              } finally {\n                r.f();\n              }\n\n              return {\n                csvTxt: t.join(",") + "\\n" + i.join(","),\n                total: a\n              };\n            }(),\n                a = document.createElement("a");\n\n            a.download = n + " (總分: ".concat(i.total, ").csv"), a.href = URL.createObjectURL(new Blob([i.csvTxt], {\n              type: "text/plain"\n            })), a.click();\n          });\n        } else console.error("Table is not rendered");\n      }\n    }, {\n      key: "renderBtn",\n      value: function value(e) {\n        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "自我評分表(助教參考用)";\n        if (e instanceof HTMLElement) {\n          if (null !== this.modal) {\n            var t = document.createElement("a");\n            t.classList.add("btn", "btn-primary"), t.innerText = n;\n            var o = this.modal;\n            t.addEventListener("click", function (e) {\n              o.isShow = !0, setTimeout(function () {\n                o.classList.add("show");\n              }, 150), o.style.display = "block";\n            }), o.addEventListener("click", function (e) {\n              o.classList.remove("show"), setTimeout(function () {\n                o.style.display = "none";\n              }, 200), o.isShow = !1;\n            }), e.appendChild(t);\n          } else console.error("Table is not rendered");\n        } else console.error("Target Element is not a valid html element");\n      }\n    }]) && n(r.prototype, l), d && n(r, d), t;\n  }();\n});\n\n//# sourceURL=webpack://font-research/./src/Lib/scoreoutputer.min.js?')},"./src/loadFont.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n/* harmony import */ var _Lib_TTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Lib/TTFLoader */ "./src/Lib/TTFLoader.js");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\nvar loadFont = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fontFile) {\n    var loadFontFn, font;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loadFontFn = function loadFontFn(url) {\n              return new Promise(function (resolve) {\n                var loader = new _Lib_TTFLoader__WEBPACK_IMPORTED_MODULE_0__.TTFLoader();\n                loader.load(url, function (json) {\n                  resolve(new three__WEBPACK_IMPORTED_MODULE_1__.Font(json));\n                });\n              });\n            };\n\n            _context.next = 3;\n            return loadFontFn(fontFile);\n\n          case 3:\n            font = _context.sent;\n            return _context.abrupt("return", font);\n\n          case 5:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function loadFont(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadFont);\n\n//# sourceURL=webpack://font-research/./src/loadFont.js?')},"./src/main.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_stable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/stable */ "./node_modules/core-js/stable/index.js");\n/* harmony import */ var core_js_stable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_stable__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n/* harmony import */ var three_orbit_controls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-orbit-controls */ "./node_modules/three-orbit-controls/index.js");\n/* harmony import */ var three_orbit_controls__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three_orbit_controls__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _loadFont__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadFont */ "./src/loadFont.js");\n/* harmony import */ var _mkFont__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mkFont */ "./src/mkFont.js");\n/* harmony import */ var _mkClock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mkClock */ "./src/mkClock.js");\n/* harmony import */ var _mkBg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mkBg */ "./src/mkBg.js");\n/* harmony import */ var _Lib_scoreoutputer_min_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Lib/scoreoutputer.min.js */ "./src/Lib/scoreoutputer.min.js");\n/* harmony import */ var _Lib_scoreoutputer_min_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_Lib_scoreoutputer_min_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ "./node_modules/bootstrap/dist/css/bootstrap.min.css");\n/* harmony import */ var _Assets_main_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Assets/main.css */ "./src/Assets/main.css");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\n\n\n\n\n\n\n\n\nwindow.addEventListener(\'load\', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n  var height, width, OrbitControls, camera, scene, dirLight, pointLight, renderer, circlePlane, fontJson, bgGroup, loadJSON, terrestrialBranch, group, raycaster, toObserve, terrestrialBranchKeys, i, xPos, yPos, meshObj, mesh, controls, mouse, currentTarget, clockObj, currentFrame, renderScene, so;\n  return regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          height = window.innerHeight;\n          width = window.innerWidth;\n          OrbitControls = three_orbit_controls__WEBPACK_IMPORTED_MODULE_2___default()(three__WEBPACK_IMPORTED_MODULE_10__);\n          camera = new three__WEBPACK_IMPORTED_MODULE_10__.PerspectiveCamera(45, width / height, 0.1, 2000);\n          scene = new three__WEBPACK_IMPORTED_MODULE_10__.Scene();\n          scene.background = new three__WEBPACK_IMPORTED_MODULE_10__.Color(0x000000);\n          scene.fog = new three__WEBPACK_IMPORTED_MODULE_10__.Fog(0x000000, 250, 1400);\n          dirLight = new three__WEBPACK_IMPORTED_MODULE_10__.DirectionalLight(0xffffff, 0.125);\n          dirLight.position.set(0, 0, 1).normalize();\n          dirLight.castShadow = true;\n          scene.add(dirLight);\n          pointLight = new three__WEBPACK_IMPORTED_MODULE_10__.PointLight(0xffffff, 1.5);\n          pointLight.castShadow = true;\n          pointLight.position.set(0, 100, 90);\n          scene.add(pointLight);\n          renderer = new three__WEBPACK_IMPORTED_MODULE_10__.WebGLRenderer({\n            antialias: true\n          });\n          renderer.setSize(width, height);\n          renderer.shadowMap.enabled = true;\n          document.getElementById("mycanvas").appendChild(renderer.domElement);\n          circlePlane = new three__WEBPACK_IMPORTED_MODULE_10__.Mesh(new three__WEBPACK_IMPORTED_MODULE_10__.CircleGeometry(100, 64), new three__WEBPACK_IMPORTED_MODULE_10__.MeshLambertMaterial({\n            color: 0x92dde8,\n            opacity: 0.5,\n            transparent: true,\n            side: three__WEBPACK_IMPORTED_MODULE_10__.DoubleSide\n          }));\n          circlePlane.castShadow = true;\n          scene.add(circlePlane);\n          _context.next = 24;\n          return (0,_loadFont__WEBPACK_IMPORTED_MODULE_3__["default"])(\'cwTeXKai-zhonly.ttf\');\n\n        case 24:\n          fontJson = _context.sent;\n          _context.next = 27;\n          return (0,_mkBg__WEBPACK_IMPORTED_MODULE_6__["default"])(fontJson, 25, 100);\n\n        case 27:\n          bgGroup = _context.sent;\n          scene.add(bgGroup);\n          console.log(bgGroup);\n          /*const axesHelper = new THREE.AxesHelper( 5 );\r\n          scene.add( axesHelper );*/\n\n          loadJSON = new Promise(function (resolve) {\n            var xhr = new XMLHttpRequest();\n\n            xhr.onload = function () {\n              resolve(JSON.parse(xhr.responseText));\n            };\n\n            xhr.open("GET", \'homework.json\');\n            xhr.send();\n          });\n          _context.next = 33;\n          return loadJSON;\n\n        case 33:\n          terrestrialBranch = _context.sent;\n          group = new three__WEBPACK_IMPORTED_MODULE_10__.Group();\n          raycaster = new three__WEBPACK_IMPORTED_MODULE_10__.Raycaster();\n          toObserve = [];\n          terrestrialBranchKeys = Object.keys(terrestrialBranch);\n          i = 0;\n\n        case 39:\n          if (!(i < terrestrialBranchKeys.length)) {\n            _context.next = 57;\n            break;\n          }\n\n          xPos = 80 * Math.sin(i * Math.PI / 6);\n          yPos = 80 * Math.cos(i * Math.PI / 6);\n          console.log(\'計算: \' + terrestrialBranchKeys[i] + \'...\');\n          console.log("x: ".concat(xPos, ", y: ").concat(yPos));\n          _context.next = 46;\n          return (0,_mkFont__WEBPACK_IMPORTED_MODULE_4__["default"])(fontJson, terrestrialBranchKeys[i], 0xffffff, 15);\n\n        case 46:\n          meshObj = _context.sent;\n          mesh = meshObj.getCircle();\n          mesh.position.x += xPos;\n          mesh.position.y += yPos;\n          mesh.info = terrestrialBranch[terrestrialBranchKeys[i]];\n          mesh.myWord = true;\n          toObserve.push(mesh);\n          group.add(mesh);\n\n        case 54:\n          i++;\n          _context.next = 39;\n          break;\n\n        case 57:\n          scene.add(group);\n          controls = new OrbitControls(camera, renderer.domElement);\n          controls.update(); //camera.position.set( 0, 100, 400 );\n\n          camera.position.set(0, 0, 400);\n          camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_10__.Vector3(0, 0, 0));\n          window.addEventListener(\'resize\', function () {\n            height = window.innerHeight;\n            width = window.innerWidth;\n            var newAspect = width / height;\n            camera.aspect = newAspect;\n            camera.updateProjectionMatrix();\n            renderer.setSize(width, height);\n          });\n          mouse = new three__WEBPACK_IMPORTED_MODULE_10__.Vector2();\n          currentTarget = null;\n          window.addEventListener(\'mousemove\', function (evt) {\n            mouse.x = evt.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(evt.clientY / window.innerHeight) * 2 + 1;\n          });\n          window.addEventListener(\'click\', function (evt) {\n            var clickHandler = function clickHandler(obj) {\n              if (obj instanceof three__WEBPACK_IMPORTED_MODULE_10__.Group && obj.myWord === true) {\n                window.open(obj.info.url, \'_blank\');\n                return null;\n              } else {\n                return obj.parent;\n              }\n            };\n\n            var tmpTarget;\n\n            if (currentTarget !== null) {\n              if ((tmpTarget = clickHandler(currentTarget)) !== null) {\n                clickHandler(tmpTarget);\n              }\n            }\n          });\n          clockObj = (0,_mkClock__WEBPACK_IMPORTED_MODULE_5__["default"])(65);\n          scene.add(clockObj);\n          window.setInterval(function () {\n            scene.remove(clockObj);\n            clockObj = (0,_mkClock__WEBPACK_IMPORTED_MODULE_5__["default"])(65);\n            scene.add(clockObj);\n          }, 1000); //let currentTime = -1;\n\n          currentFrame = 0;\n\n          renderScene = function renderScene() {\n            bgGroup.updateBallPosition(currentFrame);\n            raycaster.setFromCamera(mouse, camera);\n            var intersects = raycaster.intersectObjects(toObserve, true);\n            currentTarget = null;\n            document.body.style.cursor = \'auto\';\n\n            var _iterator = _createForOfIteratorHelper(intersects),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var intersect = _step.value;\n                document.body.style.cursor = \'pointer\';\n                currentTarget = intersect.object;\n              }\n              /*const currentFrameSecond = Math.floor(window.performance.now() / 1000);\r\n              if(currentTime != currentFrameSecond){\r\n                  currentTime = currentFrameSecond;\r\n                    scene.remove(clockObj);\r\n                  clockObj = mkClock(65);\r\n                  scene.add(clockObj);\r\n              }*/\n\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            renderer.render(scene, camera);\n            controls.update();\n            currentFrame++;\n            window.requestAnimationFrame(renderScene);\n          };\n\n          renderScene();\n          so = new (_Lib_scoreoutputer_min_js__WEBPACK_IMPORTED_MODULE_7___default())("109598105--評分表");\n          so.addChild("創建場景", 2, true);\n          so.addChild("讀取字形檔", 2, true);\n          so.addChild("將地支以圓圈排列", 2, true);\n          so.addChild("滑鼠點擊 12 地支分別跳轉網頁", 1, true);\n          so.addChild("顯示 \\"高等計算機圖形作業\\"", 1, true);\n          so.addChild("時鐘效果", 1, true);\n          so.addChild("任何 ply 格式模型", 1, true);\n          so.renderModal(document.body, backgroundColor = \'rgba(100,45,58,1)\', color = \'white\', fontSize = \'15pt\', fsFontSize = \'15px\', dialogTitle = \'自我評分表 (助教評分用)\');\n          so.installDownloadBtn();\n          so.renderBtn(document.getElementById(\'btn-container\'), "開啟自評表");\n\n        case 84:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n})));\n\n//# sourceURL=webpack://font-research/./src/main.js?')},"./src/mkBg.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n/* harmony import */ var _readObj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./readObj */ "./src/readObj.js");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\n\nvar mkBg = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(font, scale, circleRadius) {\n    var group, squarePlane, fontMaterial, fontGeometry, centerPosX, fontMesh, ballModel, ballBBox, ballRadius;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            group = new three__WEBPACK_IMPORTED_MODULE_1__.Group();\n            squarePlane = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(new three__WEBPACK_IMPORTED_MODULE_1__.PlaneGeometry(500, 500), new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n              color: 0xffffff,\n              opacity: 0.8,\n              transparent: true,\n              side: three__WEBPACK_IMPORTED_MODULE_1__.DoubleSide\n            }));\n            squarePlane.receiveShadow = true;\n            group.add(squarePlane);\n            fontMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial({\n              color: 0x464d59\n            });\n            fontGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.TextGeometry(\'高等計算機圖學作業\', {\n              font: font,\n              size: scale,\n              height: 10,\n              curveSegments: 12,\n              bevelEnabled: false,\n              bevelThickness: 10,\n              bevelSize: 4,\n              bevelOffset: 2,\n              bevelSegments: 1.5\n            });\n            fontGeometry.computeBoundingBox();\n            centerPosX = (fontGeometry.boundingBox.max.x - fontGeometry.boundingBox.min.x) / 2;\n            fontMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(fontGeometry, fontMaterial);\n            fontMesh.position.set(-1 * centerPosX, -125, 0);\n            _context.next = 12;\n            return (0,_readObj__WEBPACK_IMPORTED_MODULE_0__["default"])();\n\n          case 12:\n            ballModel = _context.sent;\n            ballBBox = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(ballModel);\n            ballRadius = Math.abs(ballBBox.max.x - ballBBox.min.x) / 2;\n            group.add(ballModel);\n            group.add(fontMesh);\n            group.rotation.x = -1 * Math.PI / 2;\n            group.position.y = -1 * circleRadius;\n            group.ballVector = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, -3, 0);\n\n            group.updateBallPosition = function (frame) {\n              var x = frame * 0.05 * group.ballVector.x;\n              var y = frame * 0.05 * group.ballVector.y;\n\n              if (ballModel.position.x + x + ballRadius > 150 || ballModel.position.x + x - ballRadius < -350) {\n                group.ballVector.x = -1 * group.ballVector.x;\n              }\n\n              if (ballModel.position.y + y + ballRadius > 250 || ballModel.position.y + y - ballRadius < -250) {\n                group.ballVector.y = -1 * group.ballVector.y;\n              }\n\n              ballModel.position.x = ballModel.position.x + x;\n              ballModel.position.y = ballModel.position.y + y;\n            };\n\n            return _context.abrupt("return", group);\n\n          case 22:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function mkBg(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mkBg);\n\n//# sourceURL=webpack://font-research/./src/mkBg.js?')},"./src/mkClock.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\n\n\nvar mkClock = function mkClock(radius) {\n  var d = new Date();\n  var currentHour = d.getHours() >= 12 ? d.getHours() - 12 : d.getHours();\n  var currentMinute = d.getMinutes();\n  var currentSecond = d.getSeconds();\n  var group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n  var material = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({\n    color: 0xffffff,\n    linewidth: 1\n  });\n  var hourGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints([new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(radius * 0.5 * Math.sin(currentHour * Math.PI / 6), radius * 0.5 * Math.cos(currentHour * Math.PI / 6), 0)]);\n  var minuteGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints([new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(radius * 0.8 * Math.sin(currentMinute * Math.PI / 30), radius * 0.8 * Math.cos(currentMinute * Math.PI / 30), 0)]);\n  var secondGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry().setFromPoints([new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(radius * 1 * Math.sin(currentSecond * Math.PI / 30), radius * 1 * Math.cos(currentSecond * Math.PI / 30), 0)]);\n  group.add(new three__WEBPACK_IMPORTED_MODULE_0__.Line(hourGeometry, material));\n  group.add(new three__WEBPACK_IMPORTED_MODULE_0__.Line(minuteGeometry, material));\n  group.add(new three__WEBPACK_IMPORTED_MODULE_0__.Line(secondGeometry, material));\n  return group;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mkClock);\n\n//# sourceURL=webpack://font-research/./src/mkClock.js?')},"./src/mkFont.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar mkFont = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(font, text, color, scale) {\n    var fontMaterial, textGeometry, textMesh, centerPosX, centerPosY, circleMesh;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!text.length) {\n              text = "沒有字";\n            }\n\n            if (isNaN(color)) {\n              color = 0xffffff;\n            }\n\n            if (isNaN(scale)) {\n              scale = 100;\n            }\n\n            fontMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshLambertMaterial({\n              color: color\n            });\n            textGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.TextGeometry(text, {\n              font: font,\n              size: scale,\n              height: 10,\n              curveSegments: 12,\n              bevelEnabled: false,\n              bevelThickness: 10,\n              bevelSize: 4,\n              bevelOffset: 2,\n              bevelSegments: 1.5\n            });\n            textGeometry.computeBoundingBox();\n            textMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(textGeometry, fontMaterial);\n            centerPosX = (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x) / 2;\n            centerPosY = (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y) / 2;\n            circleMesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.CircleGeometry(scale, 32), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n              color: 0x759be6,\n              opacity: 0.5,\n              transparent: true\n            }));\n            circleMesh.position.z = 2;\n            return _context.abrupt("return", {\n              getFontMesh: function getFontMesh() {\n                return textMesh;\n              },\n              setCenter: function setCenter() {\n                textMesh.position.x = -1 * centerPosX;\n                textMesh.position.y = -1 * centerPosY;\n              },\n              addCircle: function addCircle() {},\n              getCircle: function getCircle() {\n                var group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n                textMesh.position.x = -1 * centerPosX;\n                textMesh.position.y = -1 * centerPosY;\n                group.add(circleMesh);\n                group.add(textMesh);\n                return group;\n              }\n            });\n\n          case 12:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function mkFont(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mkFont);\n\n//# sourceURL=webpack://font-research/./src/mkFont.js?')},"./src/readObj.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var three_examples_jsm_loaders_OBJLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/OBJLoader.js */ "./node_modules/three/examples/jsm/loaders/OBJLoader.js");\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\n\n\nvar readObj = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    var loader, model;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loader = new three_examples_jsm_loaders_OBJLoader_js__WEBPACK_IMPORTED_MODULE_0__.OBJLoader();\n            _context.next = 3;\n            return new Promise(function (resolve) {\n              loader.load(\'./ball.obj\', function (mesh) {\n                resolve(mesh);\n              });\n            });\n\n          case 3:\n            model = _context.sent;\n            model.scale.set(2, 2, 2);\n            return _context.abrupt("return", model);\n\n          case 6:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function readObj() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (readObj);\n\n//# sourceURL=webpack://font-research/./src/readObj.js?')},"./src/Assets/main.css":(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n    if(true) {\n      // 1634479219828\n      var cssReload = __webpack_require__(/*! ./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js */ "./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js")(module.id, {"locals":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  \n\n//# sourceURL=webpack://font-research/./src/Assets/main.css?')},"./node_modules/webpack/hot sync ^\\.\\/log$":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var map = {\n\t"./log": "./node_modules/webpack/hot/log.js"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = "./node_modules/webpack/hot sync ^\\\\.\\\\/log$";\n\n//# sourceURL=webpack://font-research/./node_modules/webpack/hot/_sync_nonrecursive_^\\.\\/log$?')}},__webpack_module_cache__={},deferred,inProgress,dataWebpackPrefix,createStylesheet,findStylesheet,oldTags,newTags,applyHandler;function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e){if(void 0!==e.error)throw e.error;return e.exports}var r=__webpack_module_cache__[n]={id:n,loaded:!1,exports:{}};try{var t={id:n,module:r,factory:__webpack_modules__[n],require:__webpack_require__};__webpack_require__.i.forEach((function(n){n(t)})),r=t.module,t.factory.call(r.exports,r,r.exports,t.require)}catch(n){throw r.error=n,n}return r.loaded=!0,r.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.c=__webpack_module_cache__,__webpack_require__.i=[],__webpack_require__.amdO={},deferred=[],__webpack_require__.O=(n,e,r,t)=>{if(!e){var a=1/0;for(l=0;l<deferred.length;l++){for(var[e,r,t]=deferred[l],o=!0,s=0;s<e.length;s++)(!1&t||a>=t)&&Object.keys(__webpack_require__.O).every((n=>__webpack_require__.O[n](e[s])))?e.splice(s--,1):(o=!1,t<a&&(a=t));if(o){deferred.splice(l--,1);var i=r();void 0!==i&&(n=i)}}return n}t=t||0;for(var l=deferred.length;l>0&&deferred[l-1][2]>t;l--)deferred[l]=deferred[l-1];deferred[l]=[e,r,t]},__webpack_require__.n=n=>{var e=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(e,{a:e}),e},__webpack_require__.d=(n,e)=>{for(var r in e)__webpack_require__.o(e,r)&&!__webpack_require__.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},__webpack_require__.hu=n=>n+"."+__webpack_require__.h()+".hot-update.js",__webpack_require__.miniCssF=n=>n+".bundle.css",__webpack_require__.hmrF=()=>"main."+__webpack_require__.h()+".hot-update.json",__webpack_require__.h=()=>"ff2bbe1d7977e240568f",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.hmd=n=>((n=Object.create(n)).children||(n.children=[]),Object.defineProperty(n,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+n.id)}}),n),__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),inProgress={},dataWebpackPrefix="font-research:",__webpack_require__.l=(n,e,r,t)=>{if(inProgress[n])inProgress[n].push(e);else{var a,o;if(void 0!==r)for(var s=document.getElementsByTagName("script"),i=0;i<s.length;i++){var l=s[i];if(l.getAttribute("src")==n||l.getAttribute("data-webpack")==dataWebpackPrefix+r){a=l;break}}a||(o=!0,(a=document.createElement("script")).charset="utf-8",a.timeout=120,__webpack_require__.nc&&a.setAttribute("nonce",__webpack_require__.nc),a.setAttribute("data-webpack",dataWebpackPrefix+r),a.src=n),inProgress[n]=[e];var u=(e,r)=>{a.onerror=a.onload=null,clearTimeout(c);var t=inProgress[n];if(delete inProgress[n],a.parentNode&&a.parentNode.removeChild(a),t&&t.forEach((n=>n(r))),e)return e(r)},c=setTimeout(u.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=u.bind(null,a.onerror),a.onload=u.bind(null,a.onload),o&&document.head.appendChild(a)}},__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},__webpack_require__.nmd=n=>(n.paths=[],n.children||(n.children=[]),n),(()=>{var n,e,r,t,a={},o=__webpack_require__.c,s=[],i=[],l="idle";function u(n){l=n;for(var e=[],r=0;r<i.length;r++)e[r]=i[r].call(null,n);return Promise.all(e)}function c(n){if(0===e.length)return n();var r=e;return e=[],Promise.all(r).then((function(){return c(n)}))}function p(n){if("idle"!==l)throw new Error("check() is only allowed in idle status");return u("check").then(__webpack_require__.hmrM).then((function(t){return t?u("prepare").then((function(){var a=[];return e=[],r=[],Promise.all(Object.keys(__webpack_require__.hmrC).reduce((function(n,e){return __webpack_require__.hmrC[e](t.c,t.r,t.m,n,r,a),n}),[])).then((function(){return c((function(){return n?h(n):u("ready").then((function(){return a}))}))}))})):u(f()?"ready":"idle").then((function(){return null}))}))}function d(n){return"ready"!==l?Promise.resolve().then((function(){throw new Error("apply() is only allowed in ready status")})):h(n)}function h(n){n=n||{},f();var e=r.map((function(e){return e(n)}));r=void 0;var a=e.map((function(n){return n.error})).filter(Boolean);if(a.length>0)return u("abort").then((function(){throw a[0]}));var o=u("dispose");e.forEach((function(n){n.dispose&&n.dispose()}));var s,i=u("apply"),l=function(n){s||(s=n)},c=[];return e.forEach((function(n){if(n.apply){var e=n.apply(l);if(e)for(var r=0;r<e.length;r++)c.push(e[r])}})),Promise.all([o,i]).then((function(){return s?u("fail").then((function(){throw s})):t?h(n).then((function(n){return c.forEach((function(e){n.indexOf(e)<0&&n.push(e)})),n})):u("idle").then((function(){return c}))}))}function f(){if(t)return r||(r=[]),Object.keys(__webpack_require__.hmrI).forEach((function(n){t.forEach((function(e){__webpack_require__.hmrI[n](e,r)}))})),t=void 0,!0}__webpack_require__.hmrD=a,__webpack_require__.i.push((function(h){var f,m,_,g,v=h.module,y=function(r,t){var a=o[t];if(!a)return r;var i=function(e){if(a.hot.active){if(o[e]){var i=o[e].parents;-1===i.indexOf(t)&&i.push(t)}else s=[t],n=e;-1===a.children.indexOf(e)&&a.children.push(e)}else console.warn("[HMR] unexpected require("+e+") from disposed module "+t),s=[];return r(e)},p=function(n){return{configurable:!0,enumerable:!0,get:function(){return r[n]},set:function(e){r[n]=e}}};for(var d in r)Object.prototype.hasOwnProperty.call(r,d)&&"e"!==d&&Object.defineProperty(i,d,p(d));return i.e=function(n){return function(n){switch(l){case"ready":return u("prepare"),e.push(n),c((function(){return u("ready")})),n;case"prepare":return e.push(n),n;default:return n}}(r.e(n))},i}(h.require,h.id);v.hot=(f=h.id,m=v,g={_acceptedDependencies:{},_acceptedErrorHandlers:{},_declinedDependencies:{},_selfAccepted:!1,_selfDeclined:!1,_selfInvalidated:!1,_disposeHandlers:[],_main:_=n!==f,_requireSelf:function(){s=m.parents.slice(),n=_?void 0:f,__webpack_require__(f)},active:!0,accept:function(n,e,r){if(void 0===n)g._selfAccepted=!0;else if("function"==typeof n)g._selfAccepted=n;else if("object"==typeof n&&null!==n)for(var t=0;t<n.length;t++)g._acceptedDependencies[n[t]]=e||function(){},g._acceptedErrorHandlers[n[t]]=r;else g._acceptedDependencies[n]=e||function(){},g._acceptedErrorHandlers[n]=r},decline:function(n){if(void 0===n)g._selfDeclined=!0;else if("object"==typeof n&&null!==n)for(var e=0;e<n.length;e++)g._declinedDependencies[n[e]]=!0;else g._declinedDependencies[n]=!0},dispose:function(n){g._disposeHandlers.push(n)},addDisposeHandler:function(n){g._disposeHandlers.push(n)},removeDisposeHandler:function(n){var e=g._disposeHandlers.indexOf(n);e>=0&&g._disposeHandlers.splice(e,1)},invalidate:function(){switch(this._selfInvalidated=!0,l){case"idle":r=[],Object.keys(__webpack_require__.hmrI).forEach((function(n){__webpack_require__.hmrI[n](f,r)})),u("ready");break;case"ready":Object.keys(__webpack_require__.hmrI).forEach((function(n){__webpack_require__.hmrI[n](f,r)}));break;case"prepare":case"check":case"dispose":case"apply":(t=t||[]).push(f)}},check:p,apply:d,status:function(n){if(!n)return l;i.push(n)},addStatusHandler:function(n){i.push(n)},removeStatusHandler:function(n){var e=i.indexOf(n);e>=0&&i.splice(e,1)},data:a[f]},n=void 0,g),v.parents=s,v.children=[],s=[],h.require=y})),__webpack_require__.hmrC={},__webpack_require__.hmrI={}})(),__webpack_require__.p="./",createStylesheet=(n,e,r,t)=>{var a=document.createElement("link");return a.rel="stylesheet",a.type="text/css",a.onerror=a.onload=o=>{if(a.onerror=a.onload=null,"load"===o.type)r();else{var s=o&&("load"===o.type?"missing":o.type),i=o&&o.target&&o.target.href||e,l=new Error("Loading CSS chunk "+n+" failed.\n("+i+")");l.code="CSS_CHUNK_LOAD_FAILED",l.type=s,l.request=i,a.parentNode.removeChild(a),t(l)}},a.href=e,document.head.appendChild(a),a},findStylesheet=(n,e)=>{for(var r=document.getElementsByTagName("link"),t=0;t<r.length;t++){var a=(s=r[t]).getAttribute("data-href")||s.getAttribute("href");if("stylesheet"===s.rel&&(a===n||a===e))return s}var o=document.getElementsByTagName("style");for(t=0;t<o.length;t++){var s;if((a=(s=o[t]).getAttribute("data-href"))===n||a===e)return s}},oldTags=[],newTags=[],applyHandler=n=>({dispose:()=>{for(var n=0;n<oldTags.length;n++){var e=oldTags[n];e.parentNode&&e.parentNode.removeChild(e)}oldTags.length=0},apply:()=>{for(var n=0;n<newTags.length;n++)newTags[n].rel="stylesheet";newTags.length=0}}),__webpack_require__.hmrC.miniCss=(n,e,r,t,a,o)=>{a.push(applyHandler),n.forEach((n=>{var e=__webpack_require__.miniCssF(n),r=__webpack_require__.p+e,a=findStylesheet(e,r);a&&t.push(new Promise(((e,t)=>{var o=createStylesheet(n,r,(()=>{o.as="style",o.rel="preload",e()}),t);oldTags.push(a),newTags.push(o)})))}))},(()=>{var n,e,r,t,a=__webpack_require__.hmrS_jsonp=__webpack_require__.hmrS_jsonp||{main:0},o={};function s(n){return new Promise(((e,r)=>{o[n]=e;var t=__webpack_require__.p+__webpack_require__.hu(n),a=new Error;__webpack_require__.l(t,(e=>{if(o[n]){o[n]=void 0;var t=e&&("load"===e.type?"missing":e.type),s=e&&e.target&&e.target.src;a.message="Loading hot update chunk "+n+" failed.\n("+t+": "+s+")",a.name="ChunkLoadError",a.type=t,a.request=s,r(a)}}))}))}function i(o){function s(n){for(var e=[n],r={},t=e.map((function(n){return{chain:[n],id:n}}));t.length>0;){var a=t.pop(),o=a.id,s=a.chain,l=__webpack_require__.c[o];if(l&&(!l.hot._selfAccepted||l.hot._selfInvalidated)){if(l.hot._selfDeclined)return{type:"self-declined",chain:s,moduleId:o};if(l.hot._main)return{type:"unaccepted",chain:s,moduleId:o};for(var u=0;u<l.parents.length;u++){var c=l.parents[u],p=__webpack_require__.c[c];if(p){if(p.hot._declinedDependencies[o])return{type:"declined",chain:s.concat([c]),moduleId:o,parentId:c};-1===e.indexOf(c)&&(p.hot._acceptedDependencies[o]?(r[c]||(r[c]=[]),i(r[c],[o])):(delete r[c],e.push(c),t.push({chain:s.concat([c]),id:c})))}}}}return{type:"accepted",moduleId:n,outdatedModules:e,outdatedDependencies:r}}function i(n,e){for(var r=0;r<e.length;r++){var t=e[r];-1===n.indexOf(t)&&n.push(t)}}__webpack_require__.f&&delete __webpack_require__.f.jsonpHmr,n=void 0;var l={},u=[],c={},p=function(n){console.warn("[HMR] unexpected require("+n.id+") to disposed module")};for(var d in e)if(__webpack_require__.o(e,d)){var h,f=e[d],m=!1,_=!1,g=!1,v="";switch((h=f?s(d):{type:"disposed",moduleId:d}).chain&&(v="\nUpdate propagation: "+h.chain.join(" -> ")),h.type){case"self-declined":o.onDeclined&&o.onDeclined(h),o.ignoreDeclined||(m=new Error("Aborted because of self decline: "+h.moduleId+v));break;case"declined":o.onDeclined&&o.onDeclined(h),o.ignoreDeclined||(m=new Error("Aborted because of declined dependency: "+h.moduleId+" in "+h.parentId+v));break;case"unaccepted":o.onUnaccepted&&o.onUnaccepted(h),o.ignoreUnaccepted||(m=new Error("Aborted because "+d+" is not accepted"+v));break;case"accepted":o.onAccepted&&o.onAccepted(h),_=!0;break;case"disposed":o.onDisposed&&o.onDisposed(h),g=!0;break;default:throw new Error("Unexception type "+h.type)}if(m)return{error:m};if(_)for(d in c[d]=f,i(u,h.outdatedModules),h.outdatedDependencies)__webpack_require__.o(h.outdatedDependencies,d)&&(l[d]||(l[d]=[]),i(l[d],h.outdatedDependencies[d]));g&&(i(u,[h.moduleId]),c[d]=p)}e=void 0;for(var y,b=[],x=0;x<u.length;x++){var T=u[x],S=__webpack_require__.c[T];S&&(S.hot._selfAccepted||S.hot._main)&&c[T]!==p&&!S.hot._selfInvalidated&&b.push({module:T,require:S.hot._requireSelf,errorHandler:S.hot._selfAccepted})}return{dispose:function(){var n;r.forEach((function(n){delete a[n]})),r=void 0;for(var e,t=u.slice();t.length>0;){var o=t.pop(),s=__webpack_require__.c[o];if(s){var i={},c=s.hot._disposeHandlers;for(x=0;x<c.length;x++)c[x].call(null,i);for(__webpack_require__.hmrD[o]=i,s.hot.active=!1,delete __webpack_require__.c[o],delete l[o],x=0;x<s.children.length;x++){var p=__webpack_require__.c[s.children[x]];p&&((n=p.parents.indexOf(o))>=0&&p.parents.splice(n,1))}}}for(var d in l)if(__webpack_require__.o(l,d)&&(s=__webpack_require__.c[d]))for(y=l[d],x=0;x<y.length;x++)e=y[x],(n=s.children.indexOf(e))>=0&&s.children.splice(n,1)},apply:function(n){for(var e in c)__webpack_require__.o(c,e)&&(__webpack_require__.m[e]=c[e]);for(var r=0;r<t.length;r++)t[r](__webpack_require__);for(var a in l)if(__webpack_require__.o(l,a)){var s=__webpack_require__.c[a];if(s){y=l[a];for(var i=[],p=[],d=[],h=0;h<y.length;h++){var f=y[h],m=s.hot._acceptedDependencies[f],_=s.hot._acceptedErrorHandlers[f];if(m){if(-1!==i.indexOf(m))continue;i.push(m),p.push(_),d.push(f)}}for(var g=0;g<i.length;g++)try{i[g].call(null,y)}catch(e){if("function"==typeof p[g])try{p[g](e,{moduleId:a,dependencyId:d[g]})}catch(r){o.onErrored&&o.onErrored({type:"accept-error-handler-errored",moduleId:a,dependencyId:d[g],error:r,originalError:e}),o.ignoreErrored||(n(r),n(e))}else o.onErrored&&o.onErrored({type:"accept-errored",moduleId:a,dependencyId:d[g],error:e}),o.ignoreErrored||n(e)}}}for(var v=0;v<b.length;v++){var x=b[v],T=x.module;try{x.require(T)}catch(e){if("function"==typeof x.errorHandler)try{x.errorHandler(e,{moduleId:T,module:__webpack_require__.c[T]})}catch(r){o.onErrored&&o.onErrored({type:"self-accept-error-handler-errored",moduleId:T,error:r,originalError:e}),o.ignoreErrored||(n(r),n(e))}else o.onErrored&&o.onErrored({type:"self-accept-errored",moduleId:T,error:e}),o.ignoreErrored||n(e)}}return u}}}self.webpackHotUpdatefont_research=(n,r,a)=>{for(var s in r)__webpack_require__.o(r,s)&&(e[s]=r[s]);a&&t.push(a),o[n]&&(o[n](),o[n]=void 0)},__webpack_require__.hmrI.jsonp=function(n,a){e||(e={},t=[],r=[],a.push(i)),__webpack_require__.o(e,n)||(e[n]=__webpack_require__.m[n])},__webpack_require__.hmrC.jsonp=function(o,l,u,c,p,d){p.push(i),n={},r=l,e=u.reduce((function(n,e){return n[e]=!1,n}),{}),t=[],o.forEach((function(e){__webpack_require__.o(a,e)&&void 0!==a[e]&&(c.push(s(e)),n[e]=!0)})),__webpack_require__.f&&(__webpack_require__.f.jsonpHmr=function(e,r){n&&!__webpack_require__.o(n,e)&&__webpack_require__.o(a,e)&&void 0!==a[e]&&(r.push(s(e)),n[e]=!0)})},__webpack_require__.hmrM=()=>{if("undefined"==typeof fetch)throw new Error("No browser support: need fetch API");return fetch(__webpack_require__.p+__webpack_require__.hmrF()).then((n=>{if(404!==n.status){if(!n.ok)throw new Error("Failed to fetch update manifest "+n.statusText);return n.json()}}))},__webpack_require__.O.j=n=>0===a[n];var l=(n,e)=>{var r,t,[o,s,i]=e,l=0;if(o.some((n=>0!==a[n]))){for(r in s)__webpack_require__.o(s,r)&&(__webpack_require__.m[r]=s[r]);if(i)var u=i(__webpack_require__)}for(n&&n(e);l<o.length;l++)t=o[l],__webpack_require__.o(a,t)&&a[t]&&a[t][0](),a[o[l]]=0;return __webpack_require__.O(u)},u=self.webpackChunkfont_research=self.webpackChunkfont_research||[];u.forEach(l.bind(null,0)),u.push=l.bind(null,u.push.bind(u))})(),__webpack_require__.O(void 0,["vendor"],(()=>__webpack_require__("./node_modules/webpack-dev-server/client/index.js?http://localhost:8080/")));var __webpack_exports__=__webpack_require__.O(void 0,["vendor"],(()=>__webpack_require__("./src/main.js")));__webpack_exports__=__webpack_require__.O(__webpack_exports__)})();